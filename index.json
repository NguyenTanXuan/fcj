[
{
	"uri": "https://nguyentanxuan.github.io/fcj/",
	"title": "Internship Report",
	"tags": [],
	"description": "",
	"content": "Internship Report Student Information: Full Name: Nguyen Tan Xuan\nPhone Number: 0857291939\nEmail: tanxuan31052004@gmail.com\nUniversity: FPT University Ho Chi Minh city\nMajor: Information Technology\nClass: AWS092025\nInternship Company: Amazon Web Services Vietnam Co., Ltd.\nInternship Position: FCJ Cloud Intern\nInternship Duration: From 08/09/2025 to 14/12/2025\nReport Content Worklog Proposal Translated Blogs Events Participated Workshop Self-evaluation Sharing and Feedback "
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/5-workshop/5.01-workshop-overview/",
	"title": "Workshop Overview",
	"tags": [],
	"description": "",
	"content": "OJT E-commerce Architecture OJT E-commerce is a modern serverless e-commerce platform built entirely on AWS. The architecture follows best practices for scalability, security, and cost optimization, replacing traditional Spring Boot backend with AWS Lambda functions.\nKey Components Frontend: React + Vite application hosted on S3 with CloudFront CDN Backend: Serverless API using API Gateway with 11 Lambda modules (63 endpoints) Database: RDS SQL Server Express 2019 in private subnet Storage: S3 buckets for images and frontend static files Authentication: JWT-based authentication with Cognito User Pool (optional) Security: VPC with public/private subnets, Security Groups, Secrets Manager Monitoring: CloudWatch Dashboard, Log Groups, and Alarms Architecture Diagram Workshop Flow This workshop follows a practical application development workflow:\nSetup Environment - Install tools (Node.js, AWS CLI, CDK CLI) CDK Bootstrap - Prepare AWS account for CDK deployments Deploy Core Infrastructure - VPC, RDS, S3, Cognito (NetworkStack, StorageStack, AuthStack, DatabaseStack) Deploy API Stack - API Gateway + Placeholder Lambda functions Deploy Lambda Code - Deploy actual Lambda function code (63 APIs) Deploy Frontend - Build React app and deploy to S3 + CloudFront Deploy Monitoring - CloudWatch Dashboard and Alarms Test Endpoints - Verify all 63 API endpoints work end-to-end Monitor \u0026amp; Maintain - Use CloudWatch for monitoring and debugging What You\u0026rsquo;ll Learn Infrastructure as Code with AWS CDK (TypeScript) Serverless architecture replacing Spring Boot with Lambda 2-step deployment strategy: Infrastructure + Lambda code separation RDS SQL Server in private subnet with Secrets Manager CloudFront CDN with Origin Access Control (OAC) JWT authentication with optional Cognito integration Lambda function modular organization (11 modules: Auth, Products, ProductDetails, Cart, Orders, Categories, Brands, Banners, Ratings, Users, Images) VPC design with NAT Gateway for private subnet internet access CloudWatch monitoring with Dashboard and Alarms Cost optimization strategies for development environment Realistic Cost Estimate Development Environment (Optimized):\nEstimated Monthly Cost: $44/month (60% reduction from original $111/month) Cost Breakdown:\nService Configuration Monthly Cost NAT Gateway 1 instance $23 RDS SQL Server t3.micro $15 Lambda 11 modules, 128MB $2 S3 Storage Images + Frontend $1.25 CloudFront CDN distribution $1.50 CloudWatch Dashboard + Logs $1.50 Total ~$44/month Cost Optimization Applied:\nRDS instance size: t3.small → t3.micro (saves $39/month) NAT Gateway: 2 → 1 instance (saves $23/month) Lambda memory: 256MB → 128MB (saves 50% per invocation) Lambda timeout: 30s → 10s (faster execution) Log retention: 7 days → 1 day (saves 85% CloudWatch cost) Backup retention: 7 days → 1 day for development Free Tier Benefits (First 12 months):\nLambda: 1M requests/month free S3: 5GB storage + 20K GET requests free RDS: t3.micro 750 hours/month free (single-AZ) Key Features E-commerce Platform: Products, Cart, Orders, Categories, Brands 63 API Endpoints: Complete CRUD operations for all modules Image Upload: S3 integration for product images Search \u0026amp; Filter: Products by category, brand, price range Order Management: Create, track, and manage orders Rating System: Product ratings and statistics Banner Management: Dynamic banners for promotions Admin Functions: User management, order status updates Lambda Modules Summary Module Functions Description Auth 4 Login, Signup, Logout, Me Products 12 CRUD, Search, Filter, Best-selling, Newest ProductDetails 7 CRUD, Images upload Cart 6 Add, Get, Update, Remove, Clear, Count Orders 9 CRUD, COD, Status, Date-range filter Categories 6 CRUD, Search Brands 5 CRUD Banners 7 CRUD, Toggle Ratings 3 Get, Stats, Create Users 3 GetAll, GetById, UpdateProfile Images 1 Upload to S3 Total 63 Deployment Strategy 2-Step Deployment Process:\nDeploy Infrastructure (CDK) - 5-10 minutes\nVPC, Subnets, NAT Gateway RDS SQL Server + Secrets Manager S3 Buckets (Images, Frontend) API Gateway + Placeholder Lambda Cognito User Pool (optional) Deploy Lambda Code - 1-2 minutes\nPackage Lambda functions with dependencies Upload to AWS Lambda Update function code independently Benefits of Separation:\nCDK deploy faster (no Lambda code build) No dependency resolution errors Update Lambda code independently (30 seconds) Clear separation: Infrastructure vs Application code CI/CD friendly deployment "
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/4-eventparticipated/4.1-event1/",
	"title": "Event 1",
	"tags": [],
	"description": "",
	"content": "Lessons Learned: AWS Cloud Mastery Series #1 — AI/ML/GenAI on AWS 1. Event Purpose Provide an overview of AI/ML in Vietnam.\nPresent AWS\u0026rsquo;s core AI/ML services, especially Amazon SageMaker.\nClarify Generative AI applications through Amazon Bedrock and techniques such as RAG, Prompt Engineering.\n2. Main Content Morning: Overview of AWS AI/ML Services Introduce AI/ML context and workshop objectives.\nPresent Amazon SageMaker and the full ML process: Data Prep → Labeling → Training → Tuning → Deployment.\nMLOps model and integration into the development process.\nLive demo of SageMaker Studio.\nAfternoon: Generative AI with Amazon Bedrock Introduction to Foundation Models and selection criteria (Claude, Llama, Titan\u0026hellip;). Advanced Prompt Engineering techniques: Chain-of-Thought (CoT), Few-shot learning. Explain RAG architecture and integration with Knowledge Base. Bedrock Agents and how to build multi-step workflows. Guardrails and content control mechanism. Demo of building GenAI chatbot on Bedrock. 3. Knowledge extracted Understand SageMaker as a full ML platform serving the entire model lifecycle. Understand the role of Bedrock, the characteristics of each Foundation Model and core GenAI techniques. Be able to apply RAG and Bedrock Agents to improve chatbot in Travel-Guided project. Understand the actual deployment process through demos. 4. Hands-on experience Demos demonstrate Bedrock\u0026rsquo;s fast prototyping speed and strong integration capabilities. Opportunities to interact directly with AWS experts and the AI/ML community in Vietnam. "
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/1-worklog/",
	"title": "Worklog",
	"tags": [],
	"description": "",
	"content": "Typically, and as a standard, a worklog is carried out over about 3 months (throughout the internship period) with weekly contents as follows:\nWeek 1: Getting familiar with AWS and basic AWS services\nWeek 2: Learn basic AWS, get familiar and practice with Console \u0026amp; CLI\nWeek 3: Learn AWS services, EC2, and practice deploying resources\nWeek 4: Review knowledge, prepare input for system architecture design\nWeek 5: Begin designing system architecture and integrating AWS services\nWeek 6: Backend CRUD APIs for products and orders, initial MSSQL database design\nWeek 7: User management module: registration, login, and role-based access\nWeek 8: Shopping cart and payment module development; frontend API integration\nWeek 9: Progress with great strides of the Sales Web Project\nWeek 10: Understand and apply AWS to the Sales Web Project\nWeek 11: Optimize APIs, implement search, filter, sort features; documentation\nWeek 12: Finalize backend, prepare demo and deployment documentation\n"
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/3-blogstranslated/3.1-blog1/",
	"title": "Blog 1",
	"tags": [],
	"description": "",
	"content": "OpenAI Open-Weight Models Now Available on AWS OpenAI’s open-weight models are now available on AWS, giving organizations and developers the ability to integrate advanced AI with greater flexibility, scalability, and control. These models are designed for text generation, reasoning, programming, and scientific workloads, with support for context lengths up to 128K tokens and adjustable reasoning levels.\nThis blog post outlines the availability of OpenAI’s new models, the architectural choices behind their AWS integration, and how developers can get started using Amazon Bedrock and Amazon SageMaker JumpStart.\nArchitecture Guidance The new models — gpt-oss-120b and gpt-oss-20b — are available through both Amazon Bedrock and Amazon SageMaker JumpStart:\nAmazon Bedrock: Provides serverless, API-driven access to models via InvokeModel or Converse. SageMaker JumpStart: Enables fine-tuning, scalable deployment, and production integration using either the console or the Python SDK. Solution architecture highlights include:\nDirect model access via Bedrock endpoints Managed deployment options through SageMaker Support for multi-service workflows and event-driven architectures While the term open-weight models is broad, some key characteristics include:\nHigh flexibility with custom deployment options Transparency through reasoning traces for interpretability Designed for embedding into event-driven and agentic workflows Compatibility with OpenAI SDKs and AWS-native services When evaluating deployment options, consider:\nIntrinsic factors: context size, performance, reasoning quality Extrinsic factors: scalability, integration requirements, reusability Human factors: developer productivity, operational ownership Technology Choices and Communication Scope Integration Scope AWS Services / Patterns to Consider Model access \u0026amp; testing Amazon Bedrock (chat playground, APIs) Fine-tuning \u0026amp; deployment Amazon SageMaker JumpStart Event-driven workflows Amazon EventBridge, AWS Lambda, Bedrock AgentCore Tool-augmented AI agents Strands Agents with Bedrock-integrated models Hub-and-Spoke Analogy for Model Integration Similar to a pub/sub hub used in microservices, AWS enables a hub-and-spoke approach for AI integration:\nModels are accessed via Bedrock endpoints Interactions are standardized through OpenAI-compatible APIs Developers can switch between different foundation models without rewriting application logic Trade-off: careful coordination and monitoring are required to manage multiple models and reasoning levels effectively.\nCore Model Access The foundation for using OpenAI models on AWS includes:\nAmazon Bedrock for serverless inference Amazon SageMaker JumpStart for managed deployment and fine-tuning OpenAI SDK compatibility for seamless integration Reasoning trace support for improved transparency These models are production-ready and optimized for integration with existing AWS workloads.\nDeveloper Entry Point Access models through the Amazon Bedrock console: request model access and start testing in the chat playground Authenticate via AWS IAM policies Use the OpenAI SDK by pointing OPENAI_BASE_URL to the Bedrock runtime endpoint Example Python code:\nfrom openai import OpenAI client = OpenAI() response = client.chat.completions.create( messages=[{\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;Tell me the square root of 42 ^ 3\u0026#34;}], model=\u0026#34;openai.gpt-oss-120b-1:0\u0026#34;, stream=True ) for item in response: print(item) "
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/3-blogstranslated/3.2-blog2/",
	"title": "Blog 2",
	"tags": [],
	"description": "",
	"content": "AWS FOR SAP Introduction Migrating SAP landscapes to AWS gives enterprises the opportunity to modernize their infrastructure and leverage the elasticity of the cloud. Businesses can scale compute, memory, and storage within minutes and automate provisioning to reduce operational errors.\nHowever, applying auto scaling to SAP Application Servers introduces complexity. Traditionally, organizations over-provision resources to avoid system slowdowns during peak load periods—resulting in paying for maximum capacity even when it’s not needed.\nNative AWS components such as Auto Scaling groups, Target Groups, and Launch Templates do not fully address SAP’s architectural requirements. To solve this challenge, AWS Professional Services developed the SAP Auto Scaling solution, enabling horizontal scaling of SAP Application Servers and reducing infrastructure costs by up to 50%.\nBusiness Case for Auto Scaling The SAP Auto Scaling solution is designed to address real operational challenges, such as:\nEnsuring SAP environments dynamically adapt to workload demand—scaling out during peak load and scaling in when demand drops. Allowing administrators to proactively activate or deactivate servers for maintenance or system upgrades. Reducing operational overhead by automating routine infrastructure tasks. This solution provides the greatest value for customers who:\nExperience uneven workload cycles (e.g., lower usage during evenings or weekends). Are looking to reduce EC2 spend during off-peak hours. Operate production environments with three or more SAP Application Servers. Prefer flexible cost models without long-term commitments. Key Benefits Modernizes SAP environments by applying native cloud elasticity. Achieves significant EC2 cost savings—up to 50% compared to running On-Demand instances continuously. Supports predictable scaling patterns aligned with business demand. How the Solution Works SAP Auto Scaling automatically manages the active or inactive state of SAP Application Servers. It continuously monitors the usage of Dialog Work Processes on the ASCS (ABAP SAP Central Services) instance to determine when to scale.\nCore Functionality When load increases, the system starts a preconfigured EC2 instance and automatically launches its SAP services. Scale decisions (up or down) are based exclusively on Dialog Work Process utilization on the ASCS. Before a scale-down event, all active SAP GUI users receive an on-screen notification to save their work and reconnect. SAP Soft Shutdown ensures all batch jobs are completed before a server is turned off. Administrators can schedule start times for Application Servers. “No-scale windows” can be defined to block scaling during critical business hours. Critical servers can be marked as “always on.” Email notifications are sent for all scale events. Scale-Up Decision Tree The system follows a structured\n"
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/3-blogstranslated/3.3-blog3/",
	"title": "Blog 3",
	"tags": [],
	"description": "",
	"content": "Measuring the Value of Learning \u0026amp; Development (L\u0026amp;D) Programs To an L\u0026amp;D leader, the importance of employee learning is obvious. But stakeholders across the organization may not immediately see the connection. Building trust requires proving the return on investment (ROI) of learning initiatives.\nIn this post, we summarize insights from Kristin Thomas (Director, Customer Value Realization at Pluralsight) on how to demonstrate the impact of upskilling and align stakeholders around measurable business value.\nKey Components of Proving L\u0026amp;D Value Kristin highlights two essential questions:\nHave employees gained new skills? Are they applying those skills to mission-critical work? Without visibility into these two factors, it’s impossible to link learning activities to business KPIs such as retention, customer satisfaction, or ticket resolution time.\nThree Steps to Demonstrating L\u0026amp;D ROI Step 1: Understand the Business Context Before launching an upskilling initiative, identify the business problem it aims to solve. Examples include:\nCompliance requirements Faster project timelines Higher product quality Talent retention Workforce productivity Clarifying the end goal helps define which outcomes should be measured.\nStep 2: Design Upskilling for the Future of Work Determine the capabilities your teams must have after training. This creates alignment with business objectives.\nAlign with existing KPIs Study the metrics used by other teams:\nHow is productivity measured? What sales metrics reflect improvement? How do you track voluntary/involuntary turnover? How is process speed measured? Choose 1–3 primary metrics to anchor L\u0026amp;D outcomes.\nEvaluate current skill \u0026amp; confidence levels Compare what employees can do now versus what they need to support future strategy.\nHigher confidence = higher likelihood of applying new skills.\nSupport learning behaviors Enable consistent learning by:\nGiving employees dedicated learning time Explaining relevance and impact Providing tools that support new workflows Step 3: Track Learning Metrics \u0026amp; Learner Preferences Engagement metrics (hours learned, logins) are not enough. Instead, track whether:\nLearning resources match role expectations Skills gained align with business goals Employees find learning relevant and usable Preferred learning methods (classroom, digital, hands-on) are provided Continuous feedback keeps programs aligned with organizational needs.\nStart Small You don’t need a full ROI model immediately. Begin with simple metrics:\nHow many employees upskilled? What skills did they gain? How much improvement occurred? Then expand into deeper performance and business outcomes.\n"
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/1-worklog/1.1-week1/",
	"title": "Week 1 Worklog",
	"tags": [],
	"description": "",
	"content": "Week 1 Objectives: Connect and get acquainted with members of First Cloud Journey. Understand basic AWS services, how to use the console \u0026amp; CLI. Tasks to be carried out this week: Day Task Start Date Completion Date Reference Material 1 • Get acquainted with FCJ members • Read and take note of internship unit rules and regulations • Learn basic AWS lesson and set up coding environment 09/09/2025 09/09/2025 YouTube Playlist 2 • Learn about AWS service categories (Compute, Storage, Networking, Database, …) 10/09/2025 10/09/2025 Cloud Journey 3 • Create AWS Free Tier account • Learn AWS Console \u0026amp; CLI • Practice: create account, install \u0026amp; configure AWS CLI 11/09/2025 11/09/2025 Cloud Journey 4 • Learn basic EC2 concepts (Instance types, AMI, EBS, SSH, Elastic IP) 12/09/2025 12/09/2025 Cloud Journey 5 • Practice with EC2: launch instance, connect via SSH, attach EBS volume 13/09/2025 13/09/2025 Cloud Journey 6 • Review and summarize Week 1 achievements • Prepare notes/questions for Week 2 14/09/2025 14/09/2025 Personal Notes Week 1 Achievements: Understood what AWS is and mastered the basic service groups:\nCompute Storage Networking Database \u0026hellip; Successfully created and configured an AWS Free Tier account.\nBecame familiar with the AWS Management Console and learned how to find, access, and use services via the web interface.\nInstalled and configured AWS CLI on the computer, including:\nAccess Key Secret Key Default Region \u0026hellip; Used AWS CLI to perform basic operations such as:\nCheck account \u0026amp; configuration information Retrieve the list of regions View EC2 service Create and manage key pairs Check information about running services \u0026hellip; Acquired the ability to connect between the web interface and CLI to manage AWS resources in parallel.\n\u0026hellip;\n"
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/5-workshop/5.02-setup-environment/",
	"title": "Setup Environment",
	"tags": [],
	"description": "",
	"content": "Overview In this step, you will install all the necessary tools to develop and deploy the OJT E-commerce application.\nRequired Tools 1. Node.js 20.x\n# Download from https://nodejs.org/ # Or use nvm (recommended) nvm install 20 nvm use 20 # Verify installation node --version # Should be v20.x npm --version ![Node.js Installation] Screenshot: Terminal showing Node.js 20.x installed\n2. AWS CLI v2\n# Windows: Download from https://aws.amazon.com/cli/ # macOS: brew install awscli # Linux: curl \u0026#34;https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip\u0026#34; -o \u0026#34;awscliv2.zip\u0026#34; unzip awscliv2.zip sudo ./aws/install # Verify installation aws --version ![AWS CLI Installation] Screenshot: Terminal showing AWS CLI v2 installed\n3. AWS CDK CLI\n# Install CDK globally npm install -g aws-cdk # Verify installation cdk --version ![CDK CLI Installation] Screenshot: Terminal showing CDK CLI installed\n4. Git\n# Download from https://git-scm.com/ # Or use package manager # Verify installation git --version ![Git Installation]\n5. Code Editor\nRecommended: Visual Studio Code with extensions:\nAWS Toolkit GitLab Workflow ESLint Prettier AWS Account Setup 1. Create AWS Account\nIf you don\u0026rsquo;t have an AWS account:\nGo to https://aws.amazon.com/ Click \u0026ldquo;Create an AWS Account\u0026rdquo; Follow the registration process Add payment method 2. Create IAM User\nFor security, don\u0026rsquo;t use root account\nGo to IAM Console → Users → Create user Create user and save credentials ![IAM User Created] Screenshot: IAM console showing user created with AdministratorAccess\n3. Configure AWS CLI\n# Configure AWS credentials aws configure # Enter: # AWS Access Key ID: [Your Access Key] # AWS Secret Access Key: [Your Secret Key] # Default region name: ap-southeast-1 # Default output format: json ![AWS CLI Configure] Screenshot: Terminal showing aws configure completed\n4. Verify AWS Access\n# Test AWS credentials aws sts get-caller-identity # Should return your account ID and user ARN ![AWS Access Verified]\nDomain Setup (Optional) If you want to use a custom domain:\n1. Register Domain\nBuy domain name on hpanel.hostinger Route 53 creates dns record to hostinger For this workshop, we use: yourdomain.com\n2. Note Domain Registrar\nYou\u0026rsquo;ll need access to domain registrar to update nameservers later.\nGitLab Setup Create GitLab Repo\n3. Configure Git\n# Set your name and email git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;your.email@example.com\u0026#34; # Verify configuration git config --list Project Setup 1. Clone or Create Project\nOption A: Clone existing project\ngit clone https://gitlab.com/your-username/ojt-ecommerce.git cd ojt-ecommerce Option B: Create new project\nmkdir OJT cd OJT git init 2. Project Structure\nThe OJT E-commerce project has the following structure:\nOJT/\r├── OJT_infrastructure/ # CDK Infrastructure (TypeScript)\r│ └── Deploy AWS resources: VPC, RDS, S3, API Gateway, etc.\r│\r├── OJT_lambda/ # Lambda Functions (JavaScript) - 63 APIs\r│ └── Application code for API endpoints\r│\r├── OJT_frontendDev/ # Frontend (React + Vite)\r│ └── Web application\r│\r└── database/ # Database Scripts (MySQL)\r├── schema/ # Main schema\r├── migrations/ # Migration scripts\r└── seeds/ # Sample data 3. Install Dependencies\n# Install CDK Infrastructure dependencies cd OJT_infrastructure npm install # Install Lambda dependencies cd ../OJT_lambda npm install npm run install:all # Install Frontend dependencies cd ../OJT_frontendDev npm install 4. Copy Environment Variables\nFor CDK Infrastructure:\ncd OJT_infrastructure cp .env.example .env Edit .env with your values:\n# AWS Configuration AWS_ACCOUNT_ID=123456789012 AWS_REGION=ap-southeast-1 # Database Configuration DB_NAME=demoaws DB_USERNAME=admin DB_PASSWORD=YourSecurePassword123! # Application Configuration APP_NAME=OJT-Ecommerce ENVIRONMENT=dev # JWT Secret JWT_SECRET=your-super-secret-jwt-key-change-this-in-production For Lambda:\ncd ../OJT_lambda cp .env.example .env Edit .env with your values:\n# AWS Configuration AWS_REGION=ap-southeast-1 AWS_ACCOUNT_ID=your-account-id # JWT Configuration JWT_SECRET=your-jwt-secret-key JWT_EXPIRES_IN=7d Verification Check that everything is installed correctly:\n# Check Node.js node --version # v20.x # Check npm npm --version # 10.x # Check AWS CLI aws --version # aws-cli/2.x # Check CDK cdk --version # 2.x # Check Git git --version # 2.x # Check AWS credentials aws sts get-caller-identity # Check project dependencies cd OJT_infrastructure npm list --depth=0 Troubleshooting Issue: Node.js version mismatch\n# Use nvm to switch versions nvm install 20 nvm use 20 Issue: AWS CLI not found\nRestart terminal after installation Check PATH environment variable Issue: CDK command not found\n# Reinstall CDK globally npm uninstall -g aws-cdk npm install -g aws-cdk Issue: AWS credentials invalid\n# Reconfigure AWS CLI aws configure # Enter correct credentials Next Steps Once your environment is set up, proceed to [CDK Bootstrap] to prepare your AWS account for CDK deployments.\n"
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/2-proposal/",
	"title": "Proposal",
	"tags": [],
	"description": "",
	"content": "AWS First Cloud AI Journey – Project Plan Online Shopping Website: Furious Five Fashion (FFF) AWS \u0026amp; AI-Powered E-commerce Website Solution 1. Background and Motivation 1.1 Executive Summary The client is a small-sized business specializing in fashion products for young customers. They aim to build an online clothing e-commerce website using AWS and AI, with the ability to scale flexibly, support long-term growth, and optimize operational costs.\nThe goal of this project is to shift from traditional manual management on physical servers to a flexible, intelligent, and cost-efficient cloud-based model. AWS enables the system to scale at any time, maintain fast access speed, and allow the business to focus on product development instead of infrastructure.\nThe system is designed to support end-to-end e-commerce operations: hosting and distributing web content, managing product and order databases, supporting payments, and monitoring system performance. Everything aims toward stability, security, and long-term scalability.\nThe Furious Five implementation team will accompany the client throughout the process—advising, designing the architecture, and configuring key AWS services such as Lambda, S3, DynamoDB, CloudFront, and Route 53. Beyond building the system, they also help optimize costs, ensure security, and train the internal team to manage the infrastructure effectively.\nThis project is not just a technical plan—it marks an important step in the company’s digital transformation journey.\n1.2 Project Success Criteria To ensure the success of the Furious Five Fashion project, the following clear and measurable criteria must be met, representing both business goals and technical effectiveness:\nSystem Performance The website must maintain response times under 2 seconds for all user actions, even during peak hours.\nAvailability The system must achieve 99.9% uptime, monitored and automatically reported through services like CloudWatch.\nScalability AWS infrastructure must scale automatically when traffic increases by at least 2× without causing service disruption.\nCost Optimization Monthly operating costs must remain under 30% of the projected budget, supported by AWS cost-monitoring tools such as Cost Explorer and Trusted Advisor.\nSecurity No data leaks or unauthorized access. All customer data must be protected by AWS security standards (IAM policies, encryption, HTTPS, etc.).\nDeployment \u0026amp; Operations Infrastructure must be fully deployed within 4 weeks, with complete documentation so the internal team can manage the environment effectively.\nTraining \u0026amp; Knowledge Transfer The internal technical team must be trained to confidently maintain, monitor, and secure the system without depending entirely on external support.\n1.3 Assumptions To ensure alignment and smooth execution of the FFF project, the following assumptions have been made:\nThe team already has access to AWS accounts with required permissions and has basic knowledge of essential AWS services such as Lambda, S3, IAM, and Route 53. Stable Internet connectivity is assumed since all infrastructure runs in the cloud. The team is also aware of basic security and compliance requirements before deployment.\nThe project depends on multiple external factors: stable service availability in the selected AWS region, smooth domain routing via Route 53, and effective collaboration between development teams to ensure the web application operates properly in the cloud environment.\nThe project is part of an internship, so the budget is limited—favoring free-tier usage and low-cost service configurations. Due to limited experience and tight timelines, the chosen architecture remains simple and practical.\nPotential risks include IAM misconfigurations, accidental overspending due to unused resources, AWS regional outages, service incompatibilities, or limited expertise in troubleshooting cloud systems.\nDespite these risks, the project is built on clear expectations: this is a pilot environment, with layered monitoring, backup, and cost-management strategies in place. Every challenge is considered an opportunity to learn and grow in cloud engineering.\n2. SOLUTION ARCHITECTURE 2.1 Technical Architecture Diagram The following architecture is designed for FFF, deployed in AWS Region Singapore (ap-southeast-1). It emphasizes flexibility, security, automation, scalability, and simplicity—appropriate for an internship-level project while following AWS best practices.\nThe system follows a multi-layer design consisting of six key components:\nFrontend \u0026amp; Security Layer Users access the website through Route 53. Incoming traffic is protected with AWS WAF and optimized via CloudFront CDN. Source code is managed and deployed through GitLab CI/CD using CloudFormation templates.\nAPI \u0026amp; Compute Layer API Gateway routes all requests to AWS Lambda, which handles application logic. Cognito manages authentication and access control.\nStorage Layer Two S3 buckets store static content (StaticData) and user uploads.\nData Layer DynamoDB stores product metadata and unstructured data. IAM ensures secure interactions between components.\nAI Layer Amazon Rekognition and Amazon Bedrock power image processing and generative AI features.\nObservability \u0026amp; Security Layer CloudWatch, SNS, and SES provide monitoring, alerting, and system notifications.\n2.2 Technical Implementation Plan Infrastructure will be managed and deployed using Infrastructure as Code (IaC) with AWS CloudFormation to ensure repeatability, stability, and ease of maintenance. Key AWS components—S3, Lambda, API Gateway, DynamoDB, Cognito, and CloudWatch—will be defined entirely through CloudFormation templates stored in GitLab for version control and rollback capability.\nSensitive configurations such as IAM permissions or WAF rules require approval before deployment and follow the internal governance process with review and validation.\nAll critical system paths—from authentication to data processing—are covered by automated and manual test cases to ensure stability, security, and scalability.\nThis technical plan enables the FFF team to deploy and manage a professional cloud environment, learning real DevOps and AWS best practices.\n2.3 Project Plan The project follows Agile Scrum over 3 months, divided into 4 sprints.\nSprint Structure\nSprint Planning\nSetup AWS foundational services (S3, Route 53, IAM)\nConfigure security (WAF, CloudFront)\nIntegrate backend (Lambda, API Gateway, DynamoDB)\nTesting, optimization, and demo preparation\nDaily Stand-up 30-minute updates to address blockers and track status.\nSprint Review Review deliverables, demo on real AWS environment, fix issues.\nRetrospective Improve DevOps workflows and automation pipeline.\nTeam Roles\nProduct Owner: Business alignment, backlog prioritization\nScrum Master: Coordination, Agile process enforcement\nDevOps/Technical Team: Backend, infrastructure, CI/CD\nMentor / AWS Partner: Architecture validation, AI testing, cost \u0026amp; security review\nCommunication Rhythm\nDaily Stand-ups (23:00)\nWeekly Sync\nEnd-of-Sprint Demo\nKnowledge Transfer After the final sprint, the technical team will deliver hands-on training on operations, monitoring (Budgets, CloudWatch), scaling, and recovery procedures.\n2.4 Security Considerations Access Management MFA for admin users; IAM roles with least privilege; auditing through CloudTrail.\nInfrastructure Security\nEven without a dedicated VPC, services are restricted using resource policies; all public endpoints use HTTPS.\nData Protection\nS3 and DynamoDB encryption; TLS data transfer; manual periodic backups.\nDetection \u0026amp; Monitoring\nCloudTrail, Config, and CloudWatch for visibility; GuardDuty for threat detection.\nIncident Response\nClear incident workflows with log collection, analysis, and periodic simulations.\n3. PROJECT ACTIVITIES \u0026amp; DELIVERABLES 3.1 Activities \u0026amp; Deliverables Table Phase Timeline Activities Deliverables Effort(day) Infrastructure Setup Week 1 – 2 Requirements gathering, architecture design, AWS configuration (S3, CloudFront, API, Lambda, DynamoDB, Cognito), GitLab CI/CD setup Completed AWS Architecture, Ready Infrastructure, Active CI/CD 10 Frontend Development Week 3–5 UI/UX design, FE pages (Home, Catalog, Product Detail, Cart, Checkout), API integration Completed FE (Dev), Frontend connected to API 15 Backend \u0026amp; Database Week 6–9 Lambda APIs, DynamoDB setup, order/user/product logic, Cognito IAM setup Stable API, validated data flow, full FE-BE integration 20 Testing \u0026amp; Validation Week 10–11 Functional, security, performance testing, integration testing Test Report, Validated System 5 Production Launch Week 12 Deploy to production, domain \u0026amp; SSL setup, training \u0026amp; handover Live FFF Website, Documentation Package 5 3.2 Out of Scope Mobile applications (iOS/Android)\nReal inventory/logistics integration\nAdvanced admin dashboards\nCRM/ERP integrations\nAdvanced AWS security services\nReal payment gateway integration\nMultilanguage \u0026amp; multicurrency\n3.3 Go-Live Roadmap Phase 1 – POC Basic FE, S3 hosting, API integration, sample data storage, CloudFront optimization.\nPhase 2 – UAT Cognito auth, sandbox payment, CloudWatch monitoring, internal user testing.\nPhase 3 – Production Deployment Route 53 domain setup, SSL via ACM, WAF protection, CloudFront refinement.\nPhase 4 – Stabilization \u0026amp; Optimization Cost optimization, performance improvements, backup strategy, documentation updates.\n4. AWS COST ESTIMATION Estimated monthly cost: $30–35 USD\nRoute 53 : $1.00 AWS WAF : $5.00 CloudFront: $3.90 S3 (StaticData) : $0.50 S3 (Uploads): $0.75 S3 (Bucket): $0.75 AWS Lambda: $0.25 API Gateway: $3.50 Amazon Bedrock: $3.00 DynamoDB: $1.00 IAM: Free CloudWatch: $2.00 SNS: $0.10 SES: $0.20 CloudFormation: Free GitLab CI/CD : $3.00 WS Config / Setup \u0026amp; Test migration tools $5.00 (1 lần) Estimated monthly total cost: ~ $30.00 – $35.00 USD Cost assumptions:\nRegion: Singapore\n500–1000 users/month\nLow traffic\nData \u0026lt; 100GB\nFree Tier active for 12 months\nCost optimizations recommended:\nS3 Intelligent-Tiering\nCloudWatch log retention 14–30 days\nAWS Budgets alert at $40\nConsider Lambda Savings Plan for long-term workloads\n5. Project Team Project Stakeholders Name: Van Hoang Kha Title: Support Teams Description: is the Executive support person responsible for overall supervision of the FCJ internship program\nEmail/Contact information: Khab9thd@gmail.com\nPartner Project Team (Furious Five Internship Team)\nName: Duong Minh Duc Title: Project Team Leader\nDescription: Manage progress, coordinate work between the team and mentor, Manage AWS infrastructure deployment (S3, Lambda, IAM)\nEmail/Contact information: ducdmse182938@fpt.edu.vn\nName: Quach Nguyen Chi Hung\nTitle: Member\nDescription: In charge of UI/UX and user interface\nEmail/Contact information: bacon3632@gmail.com Name: Nguyen Tan Xuan\nTitle: Member\nDescription: Responsible for Backend and server logic processing\nEmail/Contact information: xuanntse184074@fpt.edu.vn\nName: Nguyen Hai Dang\nTitle: Member\nDescription: Manage AWS infrastructure deployment (S3, Lambda, IAM) and AI chat bot integration\nEmail/Contact information: dangnhse184292@fpt.edu.vn\nName: Pham Le Huy Hoang\nTitle: Member\nDescription: Testing, quality assurance and GitLab CI/CD integration, and AI chat bot integration\nEmail/Contact information: hoangplhse182670@fpt.edu.vn\nContact Complaints / Escalation Project Project\nName: Duong Minh Duc\nTitle: Project Team Leader\nDescription: Represent the internship team to contact the mentor and sponsor directly\nEmail/Contact information: ducdmse182938@fpt.edu.vn\n6. RESOURCES \u0026amp; COST ESTIMATES Resources Roles Responsibilities Rate (USD)/Hour Solution Architect(1) Design overall solutions, ensure technical feasibility, select appropriate AWS services 35 Cloud Engineer(2) Implement AWS infrastructure, configure services (S3, IAM\u0026hellip;), test and optimize systems 20 Project Manager (1) Monitor progress, coordinate teams, manage project scope and risks. 15 Support / Documentation (1) Prepare handover documents, user manuals, and final reports. 10 Estimate costs by project phase Project phase Solution Architect (hrs) 2 Engineers (hrs) Project Manager (hrs) Project Management / Support (hrs) Total Hours Survey \u0026amp; Solution Design 53 40 13 13 119 Implementation \u0026amp; Testing 67 160 21 19 267 Support / Documentation 27 53 21 19 120 Total Hours 147 253 55 51 506 Total Amount $5145 $5060 $825 $510 $11540 Cost Contribution Allocation Party Contribution (USD) % Contribution Customers 4616 40% Partners (Furious Five) 2308 20% AWS 4616 40% 7.\tACCEPTANCE Since this project is currently at the presentation stage and has not yet been formally evaluated by a customer, the following acceptance process is proposed for future delivery phases:\n7.1 Acceptance Criteria (Proposed) A deliverable will be considered acceptable when it meets the following criteria:\nFunctional features work as specified (authentication, recipe management, social features, AI functions). All APIs respond correctly and integrate with AWS services (Lambda, API Gateway, RDS, S3). Security requirements are met (JWT verification, HTTPS, access control, data encryption). UI works as expected on supported devices. No critical errors appear during test execution. 7.2 ACCEPTANCE PROCESS Review period: 8 business days for evaluation and testing. If accepted → Deliverable is signed off. If issues are found → A rejection notice will be issued with feedback. Fixes will be applied and a revised version will be resubmitted for review. If no response is received by the end of the review period → Deliverable is deemed accepted. After completing each milestone, the team submits the deliverables and documentation.\nTải file .docx "
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/4-eventparticipated/4.2-event2/",
	"title": "Event 2",
	"tags": [],
	"description": "",
	"content": "Lessons Learned: AWS Cloud Mastery Series #2 — DevOps on AWS 1. Event Objectives Enhance understanding of DevOps mindset and culture. Clarify AWS CI/CD services: CodeCommit, CodeBuild, CodeDeploy, CodePipeline. Gain knowledge of Infrastructure as Code with CloudFormation and AWS CDK. Learn about Container services (ECS, EKS, App Runner) and observability systems (CloudWatch, X-Ray). 2. Main Contents Morning: CI/CD Pipeline \u0026amp; Infrastructure as Code DevOps Mindset and DORA metrics (Deployment Frequency, MTTR…).\nCI/CD System:\nSource: CodeCommit and Git strategy.\nBuild/Test: CodeBuild.\nDeployment: CodeDeploy with Blue/Green, Canary, Rolling.\nPipeline: automation with CodePipeline.\nDemo of a complete CI/CD pipeline.\nInfrastructure as Code:\nCloudFormation: templates, stacks, drift detection.\nAWS CDK: constructs, reusable patterns, multi-language.\nDemo and discussion of appropriate IaC options.\nAfternoon: Container \u0026amp; Observability Container Services: Docker: basic containerization knowledge. Amazon ECR: storage, scanning and lifecycle image management. Amazon ECS/EKS: deployment, scaling, orchestration. App Runner: PaaS for containers. Monitoring \u0026amp; Observability: CloudWatch: metrics, logs, alarms, dashboards. AWS X-Ray: distributed tracing for microservices. Best Practices: Feature flags, A/B testing. Incident management and postmortems. Demo and case study: evaluate deployment strategy for microservices. 3. Knowledge learned Understand DevOps thinking and the meaning of DORA metrics. Understand how to coordinate between Code* services to build a complete CI/CD. Have a solid foundation in IaC (CloudFormation, CDK) to optimize multi-stack architecture. Clearly see the importance of Monitoring/Tracing through CloudWatch and X-Ray. Understand container architecture orientation with ECS/EKS for large-scale systems. Practical CI/CD \u0026amp; IaC demo, immediately applicable to projects. 4. Experience the event Clear, practical content. Demo and case study support easy visualization of the deployment process. Opportunity to connect directly with experts and the DevOps community in Vietnam. "
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/1-worklog/1.2-week2/",
	"title": "Week 2 Worklog",
	"tags": [],
	"description": "",
	"content": "Week 2 Objectives: Connect and get acquainted with members of First Cloud Journey. Understand basic AWS services, how to use the console \u0026amp; CLI. Tasks to be carried out this week: Day Task Start Date Completion Date Reference Material 2 - Get acquainted with FCJ members - Read and take note of internship unit rules and regulations 09/15/2025 09/15/2025 3 - Learn about AWS Backup: centralized backup management + How Backup Plan works + Backup schedule \u0026amp; lifecycle + Tagging \u0026amp; monitoring backups 09/16/2025 09/16/2025 https://cloudjourney.awsstudygroup.com/ 4 - Learn AWS Compute basics: + EC2 overview + Instance families \u0026amp; types + AMI (Amazon Machine Image) + Purchasing options (On-demand, Reserved, Spot) + Nitro system \u0026amp; hypervisor 09/17/2025 09/17/2025 https://cloudjourney.awsstudygroup.com/ 5 - Dive into container services: + ECS (Elastic Container Service) + EKS (Elastic Kubernetes Service) + Fargate (serverless container) + ECR (Elastic Container Registry) 09/18/2025 09/18/2025 https://cloudjourney.awsstudygroup.com/ 6 - Learn optimization \u0026amp; management: + Compute Optimizer + Auto Scaling + Hibernation - Practice: + Launch EC2 instance \u0026amp; connect + Try backup setup + Explore scaling options 09/19/2025 09/20/2025 https://cloudjourney.awsstudygroup.com/ Week 2 Achievements: Understood the role of AWS Backup as a centralized management service, while actual backup capability depends on each AWS service. Learned about EC2 instances, their operating systems, architectures (x86, ARM/Graviton), purchasing models, AMIs, and Nitro Hypervisor. Explored container services: ECS (simple), EKS (Kubernetes-based), Fargate (serverless), and ECR for storing container images. Understood optimization tools and features: Compute Optimizer, Auto Scaling, and Hibernation. Practiced with EC2: launching, connecting via SSH, attaching volumes, and trying backup configuration. Acquired a clear overview of how to choose compute and backup solutions on AWS based on cost, performance, and management needs. "
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/5-workshop/5.03-cdk-bootstrap/",
	"title": "CDK Bootstrap",
	"tags": [],
	"description": "",
	"content": "Overview AWS CDK Bootstrap prepares your AWS account for deploying CDK applications by creating essential infrastructure resources. This is a one-time setup process per AWS account/region combination that establishes the foundation for all CDK deployments.\nWhat CDK Bootstrap Creates The bootstrap process provisions the following AWS resources in your account:\n1. S3 Bucket (CDK Assets Bucket)\nStores Lambda function deployment packages Stores CloudFormation templates Stores file assets referenced by your CDK stacks Naming pattern: cdk-hnb659fds-assets-{ACCOUNT-ID}-{REGION} Versioning enabled for rollback support 2. CloudFormation Stack (CDKToolkit)\nMain infrastructure stack containing all bootstrap resources Stack name: CDKToolkit Manages lifecycle of bootstrap resources 3. IAM Roles\ncdk-hnb659fds-cfn-exec-role: CloudFormation execution role for deploying stacks cdk-hnb659fds-deploy-role: Role used by CDK CLI during deployment cdk-hnb659fds-file-publishing-role: Role for uploading assets to S3 cdk-hnb659fds-lookup-role: Role for reading environment context 4. SSM Parameters\n/cdk-bootstrap/hnb659fds/version: Stores bootstrap version number Used for compatibility checking Infrastructure Stacks Overview After bootstrapping, our OJT E-commerce project will deploy multiple CDK stacks defined in OJT_infrastructure/lib/stacks:\nStack File Description NetworkStack network-stack.ts VPC, Subnets, NAT Gateway, Security Groups StorageStack storage-stack.ts S3 Buckets (Images, Logs) AuthStack auth-stack.ts Cognito User Pool \u0026amp; Identity Pool DatabaseStack database-stack.ts RDS SQL Server + Secrets Manager ApiStack api-stack.ts API Gateway + 11 Lambda Modules FrontendStack frontend-stack.ts S3 + CloudFront (OAC) MonitoringStack monitoring-stack.ts CloudWatch Dashboard \u0026amp; Alarms These stacks depend on the bootstrap infrastructure to deploy successfully.\nLab Instructions: Bootstrap Your AWS Account Prerequisites Before beginning this lab, ensure you have:\nAWS CLI installed and configured (see section 5.02) AWS CDK CLI installed (see section 5.02) Valid AWS credentials configured IAM user with AdministratorAccess permissions or equivalent Terminal/PowerShell access to the project directory Step 1: Navigate to Infrastructure Directory cd OJT_infrastructure Step 2: Get Your AWS Account ID aws sts get-caller-identity --query Account --output text ```bash # Bootstrap CDK for ap-southeast-1 region cdk bootstrap aws://YOUR_ACCOUNT_ID/ap-southeast-1 # Example: cdk bootstrap aws://123456789012/ap-southeast-1 Expected Output:\nBootstrapping environment aws://123456789012/ap-southeast-1...\rEnvironment aws://123456789012/ap-southeast-1 bootstrapped. ![CDK Bootstrap Success] Screenshot: Terminal showing CDK bootstrap completed successfully\nStep 4: Verify Bootstrap via CLI # Check bootstrap version aws ssm get-parameter \\ --name /cdk-bootstrap/hnb659fds/version \\ --region ap-southeast-1 \\ --query Parameter.Value \\ --output text # Expected output: A version number (e.g., 19) ![Bootstrap Verification CLI] Screenshot: Terminal showing bootstrap version verification\nStep 5: Verify on AWS Console Confirm resources in the AWS Management Console.\n5.1. Verify CloudFormation Stack\nOpen [CloudFormation Console] Look for stack named CDKToolkit Status should be CREATE_COMPLETE Click on Resources tab to view created resources ![CloudFormation CDKToolkit Stack] Screenshot: CloudFormation console showing CDKToolkit stack\n5.2. Verify S3 Bucket\nOpen S3 Console Find bucket: cdk-hnb659fds-assets-{ACCOUNT-ID}-ap-southeast-1 Verify bucket properties: Versioning: Enabled ![S3 Bucket Console] Screenshot: S3 console showing CDK assets bucket\n5.3. Verify IAM Roles\nOpen IAM Roles Console Search for: cdk-hnb659fds Verify the following roles exist: cdk-hnb659fds-cfn-exec-role-{ACCOUNT-ID}-ap-southeast-1 cdk-hnb659fds-deploy-role-{ACCOUNT-ID}-ap-southeast-1 cdk-hnb659fds-file-publishing-role-{ACCOUNT-ID}-ap-southeast-1 cdk-hnb659fds-lookup-role-{ACCOUNT-ID}-ap-southeast-1 ![IAM Roles Console] Screenshot: IAM console showing CDK bootstrap roles\nUnderstanding Bootstrap Resources S3 Bucket Details The CDK assets bucket serves as a central repository for all deployment artifacts:\nPurpose: Stores CloudFormation templates, Lambda deployment packages, and static assets Lifecycle: Persists across deployments, enabling rollback capabilities Security: Encrypted at rest, bucket policies restrict access to authorized roles Naming: Deterministic naming based on account ID and region IAM Roles Details 1. CloudFormation Execution Role (cfn-exec-role)\nUsed by CloudFormation to create/update/delete stack resources Has broad permissions to manage AWS resources Trust relationship with CloudFormation service 2. Deploy Role (deploy-role)\nUsed by CDK CLI during cdk deploy operations Can assume the CloudFormation execution role Has permissions to upload assets and initiate deployments 3. File Publishing Role (file-publishing-role)\nUploads Lambda packages and assets to S3 Has S3 write permissions to the assets bucket 4. Lookup Role (lookup-role)\nReads environment context (VPCs, subnets, etc.) Read-only permissions for resource lookups Used during synthesis for context queries Cost Analysis Bootstrap Resources Cost One-time Setup:\nCloudFormation stack creation: Free IAM roles creation: Free SSM parameters: Free Ongoing Monthly Costs:\nResource Usage Cost (Estimated) S3 Storage \u0026lt; 1 GB (typical) $0.023/GB = ~$0.02/month S3 Requests Minimal (GET/PUT) ~$0.01/month IAM Roles No charge $0.00 Total Estimated Cost: ~$0.03/month (negligible)\nNote: For serverless applications, costs remain minimal as we only store Lambda deployment packages in S3.\nTroubleshooting Issue: Bootstrap fails with permission error\n# Ensure your IAM user has AdministratorAccess aws iam list-attached-user-policies --user-name YOUR_USERNAME Issue: Region mismatch\n# Verify your default region aws configure get region # Bootstrap specific region cdk bootstrap aws://ACCOUNT_ID/ap-southeast-1 Issue: CDK version mismatch\n# Update CDK CLI npm update -g aws-cdk # Verify version cdk --version Lab Completion Checklist Ensure you have completed all steps:\nStep 1: Navigate to OJT_infrastructure directory Step 2: Retrieved your AWS account ID Step 3: Executed CDK bootstrap command Step 4: Verified bootstrap version via CLI Step 5.1: Verified CDKToolkit CloudFormation stack Step 5.2: Verified CDK assets S3 bucket Step 5.3: Verified IAM roles created Summary In this lab, you successfully:\nExecuted CDK bootstrap command for your AWS account (ap-southeast-1) Created CDKToolkit CloudFormation stack Provisioned CDK assets S3 bucket for storing Lambda packages Created necessary IAM roles for CDK deployments Verified all resources via CLI and AWS Console Your AWS account is now ready to deploy serverless CDK applications, including the infrastructure stacks for the OJT E-commerce project.\nNext Steps Proceed to [Deploy Core Infrastructure] to deploy VPC, Database, Storage, and Auth stacks.\n"
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/4-eventparticipated/4.3-event3/",
	"title": "Event 3",
	"tags": [],
	"description": "",
	"content": "Lessons Learned: AWS Cloud Mastery Series #3 — AWS Well-Architected Security Pillar 1. Event Purpose Introduce the role of Security Pillar in AWS Well-Architected Framework. Present 5 pillars of security: IAM, Detection, Infrastructure Protection, Data Protection, Incident Response. Provide best practices and real-world scenarios to protect applications in the Cloud environment. 2. Main Content Pillar 1 — Identity \u0026amp; Access Management (IAM) Principles: Least Privilege, Zero Trust, Defense in Depth. Modern IAM: Avoid long-term credentials, prioritize IAM Roles and managed policies. IAM Identity Center: SSO, Permission Sets, centralized access management. Multi-account security: Service Control Policies and Permission Boundaries. Mini demo: Test IAM policy and simulate access behavior. Pillar 2 — Detection Continuous monitoring with CloudTrail (org-level), GuardDuty, Security Hub. Multi-tier logging: VPC Flow Logs, ALB logs, S3 access logs. Automated alerts via Amazon EventBridge. Pillar 3 — Infrastructure Protection Network security: network separation (public/private VPC). Defense mechanisms: Security Groups vs NACLs, AWS WAF, Shield, Network Firewall. Workload security: EC2, ECS/EKS at basic level. Pillar 4 — Data Protection At-rest and in-transit data encryption (S3, EBS, RDS, DynamoDB). KMS for key management; Secrets Manager and Parameter Store for secrets management. Data classification and access guardrails setup. Pillar 5 — Incident Response Incident Response lifecycle according to AWS. Build IR playbook and automate with Lambda/Step Functions. Sample scenario: exposed IAM keys, S3 public exposure, malware detection on EC2. 3. Learnings Understand the 5 pillars of Security Pillar and Shared Responsibility Model. Apply advanced IAM: Identity Center, SCPs, avoid using long-term credentials. Understand the importance of Data Security: KMS, secrets management. Know how to build and automate Incident Response through serverless workflows. 4. Experience the event The workshop summarizes the learning chain, strengthening the security foundation before completing the project. The IAM Identity Center and Secrets Manager sections directly solve the problem of authentication and API key management of the group. IR scenarios (like S3 public exposure) help reinforce project security policies. Q\u0026amp;A session to further guide the AWS Security Specialty certification path. "
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/3-blogstranslated/",
	"title": "Translated Blogs",
	"tags": [],
	"description": "",
	"content": "Blog 1 - OpenAI Open-Weight Models Now Available on AWS This blog introduces the availability of OpenAI’s open-weight models on AWS, enabling developers and organizations to build AI applications with greater flexibility, scalability, and transparency. You will learn how these models support text generation, reasoning, programming, and scientific workloads, how to access them through Amazon Bedrock and Amazon SageMaker JumpStart, and how features like 128K token context length and reasoning trace transparency can be leveraged to integrate AI into scalable, secure, and production-ready workflows.\nBlog 2 - AWS FOR SAP The AWS SAP Auto Scaling solution reduces EC2 costs by up to 50% by dynamically adjusting Application Servers based on real-time workload demand. It eliminates over-provisioning, scaling resources up or down while protecting active jobs via Soft Shutdown protocols. This automated approach optimizes efficiency and performance for enterprises with fluctuating usage patterns.\nBlog 3 - Measuring the Value of Learning \u0026amp; Development (L\u0026amp;D) Programs This blog demonstrate the ROI of Learning \u0026amp; Development (L\u0026amp;D), leaders must link upskilling directly to business outcomes rather than just tracking engagement metrics. This involves identifying specific organizational problems, aligning training with existing KPIs, and verifying that employees apply new skills to mission-critical tasks. By starting with clear metrics on skill acquisition and application, organizations can build trust with stakeholders and prove the tangible value of their learning programs.\n"
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/1-worklog/1.3-week3/",
	"title": "Week 3 Worklog",
	"tags": [],
	"description": "",
	"content": "Week 3 Objectives: Understand AWS Database services and their use cases. Learn about AWS Security concepts and services. Tasks to be carried out this week: Day Task Start Date Completion Date Reference Material 2 - Introduction to Amazon RDS and Aurora - Learn about Multi-AZ Deployment, Read Replica, Automatic Backup, Snapshot 09/22/2025 09/22/2025 https://cloudjourney.awsstudygroup.com/ 3 - Practice monitoring tools: CloudWatch, Enhanced Monitoring, Performance Insight - Introduction to AWS DMS \u0026amp; Schema Conversion Tool for database migration 09/23/2025 09/23/2025 https://cloudjourney.awsstudygroup.com/ 4 - Learn about Amazon DynamoDB (NoSQL) - Understand Purpose-built Database concept and suitable use cases 09/24/2025 09/24/2025 https://cloudjourney.awsstudygroup.com/ 5 - Data Lake concepts on AWS - Services: S3, Glue Crawler, Glue Data Catalog, Athena 09/25/2025 09/25/2025 https://cloudjourney.awsstudygroup.com/ 6 - Security basics: Shared Responsibility Model - Learn AWS IAM for identity \u0026amp; access management - Explore AWS Organizations and AWS SSO for account \u0026amp; identity management 09/26/2025 09/26/2025 https://cloudjourney.awsstudygroup.com/ 7 - Introduction to Compliance \u0026amp; Security Hub - Review overall AWS Security practices and governance 09/27/2025 09/27/2025 https://cloudjourney.awsstudygroup.com/ Week 3 Achievements: Understood Amazon RDS, Aurora, DynamoDB, and Purpose-built Databases. Practiced monitoring with CloudWatch, Enhanced Monitoring, and Performance Insight. Learned database migration tools: AWS DMS \u0026amp; Schema Conversion Tool. Gained knowledge about Data Lake architecture using S3, Glue, and Athena. Understood the Shared Responsibility Model for AWS Security. Used IAM for access management and explored AWS Organizations \u0026amp; SSO for multi-account governance. Introduced to Compliance \u0026amp; Security Hub for compliance and governance monitoring. "
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/5-workshop/5.04-configure-stacks/",
	"title": "Configure Infrastructure Stacks",
	"tags": [],
	"description": "",
	"content": "Configure Infrastructure Stacks OJT E-commerce Project Overview Introduction OJT E-commerce is a serverless e-commerce platform built entirely on AWS Cloud. The project uses a serverless architecture with Lambda functions replacing traditional Spring Boot backend, leveraging AWS managed services to ensure scalability, security, and cost optimization.\nSystem Architecture The project is designed with a 7-Stack Architecture featuring clear layers:\n┌─────────────────────────────────────────────────────────────┐\r│ OJT E-commerce Platform │\r├─────────────────────────────────────────────────────────────┤\r│ Layer 1: Network (Foundation) │\r│ └─ Network Stack: VPC, Subnets, NAT Gateway, Security Groups│\r├─────────────────────────────────────────────────────────────┤\r│ Layer 2: Data \u0026amp; Storage │\r│ ├─ Storage Stack: S3 Buckets (Images, Logs) │\r│ └─ Database Stack: RDS SQL Server, Secrets Manager │\r├─────────────────────────────────────────────────────────────┤\r│ Layer 3: Authentication │\r│ └─ Auth Stack: Cognito User Pool, Identity Pool │\r├─────────────────────────────────────────────────────────────┤\r│ Layer 4: Application \u0026amp; Business Logic │\r│ └─ API Stack: API Gateway, 11 Lambda Modules │\r├─────────────────────────────────────────────────────────────┤\r│ Layer 5: Content Delivery │\r│ └─ Frontend Stack: S3 Static Hosting, CloudFront CDN │\r├─────────────────────────────────────────────────────────────┤\r│ Layer 6: Monitoring \u0026amp; Observability │\r│ └─ Monitoring Stack: CloudWatch Dashboard, Alarms │\r└─────────────────────────────────────────────────────────────┘ Technologies Used Infrastructure as Code AWS CDK (TypeScript): Infrastructure management with code CloudFormation: Underlying template engine for CDK Git: Version control for infrastructure code Backend Services API Gateway REST API: RESTful API endpoint Lambda Functions: Serverless compute for business logic RDS SQL Server: Relational database S3: Object storage for product images and frontend Secrets Manager: Secure credential storage Security \u0026amp; Authentication Cognito User Pool: User authentication \u0026amp; management JWT Authentication: Custom JWT-based auth in Lambda VPC: Network isolation with public/private/isolated subnets Security Groups: Firewall rules for resources IAM Roles \u0026amp; Policies: Fine-grained access control Content Delivery \u0026amp; Networking CloudFront: CDN with Origin Access Control (OAC) NAT Gateway: Internet access for private subnets VPC Endpoints: Private connectivity to AWS services Monitoring \u0026amp; Operations CloudWatch Logs: Centralized logging for Lambda functions CloudWatch Metrics: Performance metrics tracking CloudWatch Dashboard: Visualization of metrics CloudWatch Alarms: Real-time monitoring alerts Project Directory Structure OJT/\r├── OJT_infrastructure/ # AWS CDK Infrastructure\r│ ├── bin/\r│ │ └── infrastructure.ts # CDK app entry point\r│ ├── lib/\r│ │ └── stacks/ # Stack definitions\r│ │ ├── network-stack.ts # VPC, Subnets, NAT Gateway\r│ │ ├── storage-stack.ts # S3 Buckets\r│ │ ├── auth-stack.ts # Cognito User Pool\r│ │ ├── database-stack.ts # RDS SQL Server\r│ │ ├── api-stack.ts # API Gateway + Lambda\r│ │ ├── frontend-stack.ts # S3 + CloudFront\r│ │ └── monitoring-stack.ts # CloudWatch\r│ ├── .env.example # Environment template\r│ ├── package.json # Node.js dependencies\r│ └── tsconfig.json # TypeScript configuration\r│\r├── OJT_lambda/ # Lambda Functions (63 APIs)\r│ ├── auth/ # Authentication (4 functions)\r│ ├── products/ # Products (12 functions)\r│ ├── product-details/ # Product Details (7 functions)\r│ ├── cart/ # Cart (6 functions)\r│ ├── orders/ # Orders (9 functions)\r│ ├── categories/ # Categories (6 functions)\r│ ├── brands/ # Brands (5 functions)\r│ ├── banners/ # Banners (7 functions)\r│ ├── ratings/ # Ratings (3 functions)\r│ ├── users/ # Users (3 functions)\r│ ├── images/ # Images (1 function)\r│ └── shared/ # Shared utilities\r│\r├── OJT_frontendDev/ # Frontend (React + Vite)\r│ ├── src/ # Source code\r│ └── public/ # Static assets\r│\r└── database/ # Database Scripts\r├── schema/ # SQL schema files\r├── migrations/ # Migration scripts\r└── seeds/ # Sample data Stack Architecture Overview 1. Network Stack (Deploy Order: 1) Purpose: Create VPC and network infrastructure\nMain resources:\nVPC: 10.0.0.0/16 CIDR block Public Subnets: 2 AZs - Internet-facing resources Private Subnets: 2 AZs - Lambda functions, internal services Isolated Subnets: 2 AZs - RDS database (no internet) NAT Gateway: 1 instance (cost optimized) Internet Gateway: VPC internet access Security Groups: Lambda SG, RDS SG VPC Endpoints: S3, Secrets Manager Estimated cost: ~$23/month (NAT Gateway)\n2. Storage Stack (Deploy Order: 2) Purpose: Create S3 buckets for images and logs\nMain resources:\nImages Bucket: Product images storage Versioning enabled Lifecycle rules for cost optimization Logs Bucket: CloudFront access logs Auto-delete after 90 days Estimated cost: ~$1-3/month\n3. Auth Stack (Deploy Order: 2) Purpose: User authentication with Cognito (Optional)\nMain resources:\nCognito User Pool: User registration and authentication Email verification required Password policy: 8+ chars, mixed case, numbers, symbols Cognito User Pool Client: Frontend authentication Cognito Identity Pool: AWS credentials for authenticated users Estimated cost: $0/month (Free tier: 50,000 MAU)\nNote: This stack is optional. The project also supports custom JWT authentication in Lambda.\n4. Database Stack (Deploy Order: 2) Purpose: SQL Server database with Secrets Manager\nMain resources:\nRDS SQL Server Express 2019: Instance: db.t3.micro (cost optimized) Storage: 20 GB gp3 SSD Multi-AZ: Disabled (dev/staging) Backup: 1 day retention Secrets Manager: Database credentials Auto-generated strong password Optional rotation Estimated cost: ~$15/month (optimized from $54)\n5. API Stack (Deploy Order: 3) Purpose: REST API with API Gateway and Lambda functions\nMain resources:\nAPI Gateway REST API: 63 endpoints across 11 modules CORS enabled CloudWatch logging Lambda Functions (11 modules): Auth, Products, ProductDetails, Cart, Orders Categories, Brands, Banners, Ratings, Users, Images Runtime: Node.js 20.x Memory: 128-512 MB (optimized) VPC: Private subnets Estimated cost: ~$2-5/month\n6. Frontend Stack (Deploy Order: 4) Purpose: Static website hosting with CDN\nMain resources:\nS3 Bucket: React build files CloudFront Distribution: Origin Access Control (OAC) HTTPS only Gzip compression Estimated cost: ~$1-2/month\n7. Monitoring Stack (Deploy Order: 5) Purpose: Monitoring, logging, and alerting\nMain resources:\nCloudWatch Dashboard: System metrics visualization CloudWatch Alarms: API Gateway 5xx errors Lambda errors RDS CPU utilization CloudWatch Log Groups: Lambda function logs Estimated cost: ~$1-2/month\nStack Dependencies Flow Network Stack (VPC, Subnets, NAT Gateway)\r↓\r┌─────────────────────────────────────┐\r│ Storage Stack Auth Stack │\r│ (S3 Buckets) (Cognito) │\r│ │\r│ Database Stack │\r│ (RDS SQL Server) │\r└─────────────────────────────────────┘\r↓\rAPI Stack (API Gateway + Lambda)\r↓\rFrontend Stack (S3 + CloudFront)\r↓\rMonitoring Stack (CloudWatch) Total Estimated Cost Development Environment:\nService Cost/month Notes NAT Gateway $23 1 instance RDS SQL Server $15 t3.micro Lambda $2 11 modules, 128MB S3 Storage $1.25 Images + Frontend CloudFront $1.50 CDN distribution CloudWatch $1.50 Dashboard + Logs Cognito $0 Free tier (50K MAU) API Gateway $0-3 Free tier (1M requests) TOTAL ~$44/month 60% reduction from $111 Configuration Guide Step 1: Navigate to Infrastructure Directory cd OJT_infrastructure Step 2: Install Dependencies npm install Step 3: Configure Environment Variables 1. Copy environment template\ncopy .env.example .env 2. Edit .env file with your values\n# AWS Configuration AWS_ACCOUNT_ID=123456789012 AWS_REGION=ap-southeast-1 # Database Configuration DB_NAME=demoaws DB_USERNAME=admin DB_PASSWORD=YourSecurePassword123! # Application Configuration APP_NAME=OJT-Ecommerce ENVIRONMENT=dev # JWT Secret JWT_SECRET=your-super-secret-jwt-key-change-this-in-production 3. Verify AWS Account ID\naws sts get-caller-identity Output:\n{ \u0026#34;UserId\u0026#34;: \u0026#34;AIDAXXXXXXXXXXXXXXXXX\u0026#34;, \u0026#34;Account\u0026#34;: \u0026#34;123456789012\u0026#34;, \u0026#34;Arn\u0026#34;: \u0026#34;arn:aws:iam::123456789012:user/your-username\u0026#34; } Step 4: Validate Configuration 1. Compile TypeScript\nnpm run build 2. List all CDK stacks\nnpx cdk list Expected output:\nOJT-NetworkStack\rOJT-StorageStack\rOJT-AuthStack\rOJT-DatabaseStack\rOJT-ApiStack\rOJT-FrontendStack\rOJT-MonitoringStack 3. Synthesize CloudFormation templates\nnpx cdk synth The cdk.out/ folder is created with CloudFormation templates.\nStep 5: Review Stack Code (Optional) Network Stack (lib/stacks/network-stack.ts):\nVPC with 10.0.0.0/16 CIDR Public, Private, Isolated subnets 1 NAT Gateway (cost optimized) Security Groups for Lambda and RDS Database Stack (lib/stacks/database-stack.ts):\nRDS SQL Server Express 2019 db.t3.micro instance (cost optimized) Secrets Manager for credentials 1-day backup retention API Stack (lib/stacks/api-stack.ts):\nAPI Gateway REST API 11 Lambda modules with placeholder code VPC integration for database access Configuration Checklist Before deploying, verify the following:\nEnvironment Configuration\nAWS Account ID verified and updated in .env Region set to ap-southeast-1 Database credentials configured JWT secret configured Dependencies\nNode.js 20.x installed AWS CLI configured with credentials AWS CDK CLI installed globally npm dependencies installed (npm install) Validation\nTypeScript compilation successful (npm run build) CDK list shows all 7 stacks CDK synth generates CloudFormation templates Preparation\nCDK bootstrap completed AWS account has AdministratorAccess permissions Next Steps After completing configuration and validation, continue to:\nDeploy all stacks to AWS In the next step, you will:\nDeploy Network Stack (VPC, Subnets, NAT Gateway) Deploy Storage Stack (S3 Buckets) Deploy Auth Stack (Cognito - optional) Deploy Database Stack (RDS SQL Server) Deploy API Stack (API Gateway + Lambda) Deploy Frontend Stack (S3 + CloudFront) Deploy Monitoring Stack (CloudWatch) "
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/4-eventparticipated/",
	"title": "Events Participated",
	"tags": [],
	"description": "",
	"content": "During my internship, I participated in two events. Each one was a memorable experience that provided new, interesting, and useful knowledge, along with gifts and wonderful moments.\nEvent 1 Event Name: AWS Cloud Mastery Series #1 — AI/ML/GenAI on AWS\nTime: 09:00 November 15, 2025\nLocation: 26th Floor, Bitexco Building, 02 Hai Trieu Street, Saigon Ward, Ho Chi Minh City\nRole in the event: Attendees\nEvent 2 Event name: AWS Cloud Mastery Series #2 — DevOps on AWS\nTime: 09:00 November 17, 2025\nLocation: 26th Floor, Bitexco Building, No. 02 Hai Trieu Street, Saigon Ward, Ho Chi Minh City\nRole in the event: Attendees\nEvent 3 Event name: AWS Cloud Mastery Series #3 — According to AWS Well-Architected Security Pillar\nTime: 09:00 November 29/11/2025\nLocation: 26th Floor, Bitexco Building, 02 Hai Trieu Street, Saigon Ward, Ho Chi Minh City\nRole in the event: Attendees\n"
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/1-worklog/1.4-week4/",
	"title": "Week 4 Worklog",
	"tags": [],
	"description": "",
	"content": "Week 4 Objectives: Connect and collaborate with team members to discuss the overall direction of the clothing e-commerce website project. Learn about the backend structure, technology stack, and define team roles. Start exploring how to integrate AWS services (such as S3, EC2, and RDS) into the backend system. Tasks to be carried out this week: Day Task Start Date Completion Date Reference Material 2 - Meet team members and discuss project overview - Define main roles and responsibilities (Backend, Frontend, UI/UX, etc.) 09/29/2025 09/29/2025 Team meeting notes 3 - Explore backend project structure (Spring Boot) - Set up local development environment - Learn about existing API structure and database schema 09/30/2025 09/30/2025 Internal GitHub repo 4 - Research AWS services for potential integration + AWS S3 for image storage + AWS RDS for database hosting + AWS EC2 for backend deployment 10/01/2025 10/01/2025 AWS Documentation 5 - Discuss deployment strategy with the team - Plan backend endpoints related to product management (CRUD for clothing items) 10/02/2025 10/02/2025 Internal Docs 6 - Begin designing and coding API endpoints + Product listing + Category management + Image upload testing (with AWS S3) 10/03/2025 10/03/2025 Spring Boot Docs Week 4 Achievements: Connected and communicated effectively with team members to understand the project’s goals and workflow. Clearly defined the backend role and successfully set up the local development environment. Understood the overall architecture of the clothing e-commerce website, including database design, service layer, and API flow. Researched and evaluated AWS services for integration: AWS S3 — for storing product images. AWS RDS — for hosting the MySQL database. AWS EC2 — for backend deployment. Contributed to designing product-related APIs (CRUD operations). Successfully tested image upload and retrieval using AWS S3. Strengthened knowledge of backend workflows and AWS integration in real-world web applications. "
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/5-workshop/5.05-configure-api-lambda/",
	"title": "Configure API &amp; Lambda",
	"tags": [],
	"description": "",
	"content": "Overview Sau khi deploy infrastructure, bạn cần cấu hình API Gateway routes và Lambda functions để xử lý business logic. Dự án OJT E-commerce sử dụng kiến trúc 2-step deployment: Infrastructure (CDK) và Lambda Code (riêng biệt).\nAPI Architecture API Gateway (REST API)\r↓\r┌─────────────────────────────────────────────────────────────────┐\r│ 11 Lambda Modules (63 APIs) │\r├─────────┬─────────┬─────────┬─────────┬─────────┬───────────────┤\r│ Auth │Products │ Cart │ Orders │Categories│ Brands │\r│(4 APIs) │(12 APIs)│(6 APIs) │(9 APIs) │ (6 APIs) │ (5 APIs) │\r├─────────┼─────────┼─────────┼─────────┼─────────┼───────────────┤\r│ Banners │ Ratings │ Users │ Images │ Product │ │\r│(7 APIs) │(3 APIs) │(3 APIs) │(1 API) │ Details │ │\r│ │ │ │ │(7 APIs) │ │\r└─────────┴─────────┴─────────┴─────────┴─────────┴───────────────┘\r↓ ↓ ↓ ↓ ↓\rRDS SQL Server S3 Images\r(via Secrets Manager) Step 1: Review Project Structure Lambda Functions Structure:\nOJT_lambda/\r├── shared/ # Shared utilities\r│ ├── database.js # RDS connection helper\r│ ├── auth.js # JWT utilities\r│ └── response.js # API response formatters\r├── auth/ # Authentication (4 functions)\r│ ├── login.js # POST /auth/login\r│ ├── signup.js # POST /auth/signup\r│ ├── logout.js # POST /auth/logout\r│ └── me.js # GET /auth/me\r├── products/ # Products (12 functions)\r│ ├── getProducts.js # GET /products\r│ ├── getProductDetail.js # GET /products/detail/{id}\r│ ├── createProduct.js # POST /products\r│ ├── updateProduct.js # PUT /products/{id}\r│ ├── deleteProduct.js # DELETE /products/{id}\r│ ├── searchProducts.js # GET /products/search\r│ ├── getBestSelling.js # GET /products/best-selling\r│ ├── getNewest.js # GET /products/newest\r│ └── ...\r├── cart/ # Cart (6 functions)\r├── orders/ # Orders (9 functions)\r├── categories/ # Categories (6 functions)\r├── brands/ # Brands (5 functions)\r├── banners/ # Banners (7 functions)\r├── ratings/ # Ratings (3 functions)\r├── users/ # Users (3 functions)\r├── images/ # Images (1 function)\r└── product-details/ # Product Details (7 functions) Step 2: Configure Lambda Environment Variables 1. Navigate to Lambda project\ncd OJT_lambda 2. Copy environment template\ncopy .env.example .env 3. Edit .env file\n# AWS Configuration AWS_REGION=ap-southeast-1 AWS_ACCOUNT_ID=123456789012 # Database Configuration (from CDK outputs) DB_HOST=ojt-database.xxx.ap-southeast-1.rds.amazonaws.com DB_NAME=demoaws DB_SECRET_ARN=arn:aws:secretsmanager:ap-southeast-1:123456789012:secret:OJT/RDS/Credentials # JWT Configuration JWT_SECRET=your-jwt-secret-key JWT_EXPIRES_IN=7d # S3 Images Bucket (from CDK outputs) S3_IMAGES_BUCKET=ojt-ecommerce-images-123456789012 4. Get values from CDK outputs\n# Get RDS endpoint aws rds describe-db-instances ` --db-instance-identifier ojt-database ` --query \u0026#39;DBInstances[0].Endpoint.Address\u0026#39; ` --output text # Get Secrets Manager ARN aws secretsmanager list-secrets ` --query \u0026#34;SecretList[?contains(Name, \u0026#39;OJT\u0026#39;)].ARN\u0026#34; ` --output text # Get S3 bucket name aws s3 ls | Select-String \u0026#34;ojt-ecommerce-images\u0026#34; Step 3: Review API Endpoints Authentication APIs (4 endpoints):\nMethod Endpoint Handler Description POST /auth/login login.js User login POST /auth/signup signup.js User registration POST /auth/logout logout.js User logout GET /auth/me me.js Get current user Products APIs (12 endpoints):\nMethod Endpoint Handler Description GET /products getProducts.js List all products GET /products/detail/{id} getProductDetail.js Product detail POST /products createProduct.js Create product (Admin) PUT /products/{id} updateProduct.js Update product (Admin) DELETE /products/{id} deleteProduct.js Delete product (Admin) GET /products/search searchProducts.js Search products GET /products/best-selling getBestSelling.js Best selling products GET /products/newest getNewest.js Newest products GET /products/category/{id} getProductsByCategory.js Products by category GET /products/brand/{id} getProductsByBrand.js Products by brand GET /products/price-range getProductsByPriceRange.js Products by price Cart APIs (6 endpoints):\nMethod Endpoint Handler Description POST /cart addToCart.js Add to cart GET /cart/me getMyCart.js Get user\u0026rsquo;s cart PUT /cart/{id} updateCartItem.js Update cart item DELETE /cart/{id} removeCartItem.js Remove cart item DELETE /cart clearCart.js Clear cart GET /cart/count getCartCount.js Get cart count Orders APIs (9 endpoints):\nMethod Endpoint Handler Description GET /orders getAllOrders.js All orders (Admin) POST /orders createOrder.js Create order POST /orders/create-cod createOrderCOD.js Create COD order GET /orders/{id}/details getOrderDetails.js Order details GET /orders/user/{userId} getUserOrders.js User\u0026rsquo;s orders PATCH /orders/{id}/status updateOrderStatus.js Update status DELETE /orders/{id} cancelOrder.js Cancel order Step 4: Install Lambda Dependencies # Install main dependencies cd OJT_lambda npm install # Install all module dependencies npm run install:all This installs dependencies for:\nshared/ - Database, auth, response utilities auth/ - bcryptjs, jsonwebtoken products/ - Database queries cart/, orders/, etc. Step 5: Review Shared Utilities Database Helper (shared/database.js):\nconst sql = require(\u0026#39;mssql\u0026#39;); const config = { server: process.env.DB_HOST, database: process.env.DB_NAME, user: process.env.DB_USERNAME, password: process.env.DB_PASSWORD, options: { encrypt: true, trustServerCertificate: true } }; async function query(sqlQuery, params = []) { const pool = await sql.connect(config); const result = await pool.request(); // Add parameters params.forEach((param, index) =\u0026gt; { result.input(`param${index}`, param); }); return result.query(sqlQuery); } module.exports = { query, sql }; Auth Helper (shared/auth.js):\nconst jwt = require(\u0026#39;jsonwebtoken\u0026#39;); function generateToken(user) { return jwt.sign( { userId: user.UserID, email: user.Email, role: user.Role }, process.env.JWT_SECRET, { expiresIn: process.env.JWT_EXPIRES_IN || \u0026#39;7d\u0026#39; } ); } function verifyToken(token) { return jwt.verify(token, process.env.JWT_SECRET); } module.exports = { generateToken, verifyToken }; Response Helper (shared/response.js):\nfunction success(data, statusCode = 200) { return { statusCode, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39; }, body: JSON.stringify(data) }; } function error(message, statusCode = 500) { return { statusCode, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39; }, body: JSON.stringify({ error: message }) }; } module.exports = { success, error }; Step 6: Verify API Gateway Configuration 1. Get API Gateway URL from CDK outputs\n# Get API Gateway URL aws cloudformation describe-stacks ` --stack-name OJT-ApiStack ` --query \u0026#39;Stacks[0].Outputs[?OutputKey==`ApiUrl`].OutputValue\u0026#39; ` --output text Expected output:\nhttps://xxxxxxxxxx.execute-api.ap-southeast-1.amazonaws.com/prod 2. Check API Gateway resources\n# Get API ID $API_ID = aws apigateway get-rest-apis ` --query \u0026#34;items[?contains(name, \u0026#39;OJT\u0026#39;)].id\u0026#34; ` --output text # List resources aws apigateway get-resources --rest-api-id $API_ID Step 7: Verify Lambda Functions 1. List Lambda functions\naws lambda list-functions ` --query \u0026#34;Functions[?contains(FunctionName, \u0026#39;OJT-Ecommerce\u0026#39;)].FunctionName\u0026#34; ` --output table Expected output:\nOJT-Ecommerce-AuthModule\rOJT-Ecommerce-ProductsModule\rOJT-Ecommerce-ProductDetailsModule\rOJT-Ecommerce-CartModule\rOJT-Ecommerce-OrdersModule\rOJT-Ecommerce-CategoriesModule\rOJT-Ecommerce-BrandsModule\rOJT-Ecommerce-BannersModule\rOJT-Ecommerce-RatingsModule\rOJT-Ecommerce-UsersModule\rOJT-Ecommerce-ImagesModule 2. Check Lambda environment variables\naws lambda get-function-configuration ` --function-name OJT-Ecommerce-AuthModule ` --query \u0026#39;Environment.Variables\u0026#39; Step 8: Test Lambda Functions Locally 1. Test Auth Login\ncd OJT_lambda # Test login handler node -e \u0026#34; const handler = require(\u0026#39;./auth/login.js\u0026#39;).handler; const event = { body: JSON.stringify({ email: \u0026#39;test@test.com\u0026#39;, password: \u0026#39;Test123!\u0026#39; }) }; handler(event).then(console.log); \u0026#34; 2. Test Products List\n# Test get products handler node -e \u0026#34; const handler = require(\u0026#39;./products/getProducts.js\u0026#39;).handler; const event = { queryStringParameters: { page: \u0026#39;1\u0026#39;, limit: \u0026#39;10\u0026#39; } }; handler(event).then(console.log); \u0026#34; Step 9: Build Lambda Packages # Build all Lambda packages npm run build # Or build specific module npm run build:auth npm run build:products This creates ZIP files in build/ directory:\nbuild/\r├── auth.zip\r├── products.zip\r├── product-details.zip\r├── cart.zip\r├── orders.zip\r├── categories.zip\r├── brands.zip\r├── banners.zip\r├── ratings.zip\r├── users.zip\r└── images.zip Configuration Checklist Lambda project structure reviewed Environment variables configured in .env Database connection details obtained from CDK outputs JWT secret configured S3 bucket name configured Dependencies installed (npm install + npm run install:all) Shared utilities reviewed (database, auth, response) API Gateway URL obtained Lambda functions listed and verified Local tests passing Lambda packages built (npm run build) API Summary Module Functions Endpoints Auth 4 login, signup, logout, me Products 12 CRUD + search, filter, best-selling, newest Product Details 7 CRUD + images upload Cart 6 add, get, update, remove, clear, count Orders 9 CRUD + COD, status, date-range Categories 6 CRUD + search Brands 5 CRUD Banners 7 CRUD + toggle Ratings 3 get, stats, create Users 3 getAll, getById, updateProfile Images 1 upload Total 63 Next Steps Once configuration is complete, proceed to [Deploy Backend] to deploy your Lambda code to AWS.\n"
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/5-workshop/",
	"title": "Workshop",
	"tags": [],
	"description": "",
	"content": "Building Furious Five Fashion: AWS Full-Stack Infrastructure Workshop Overview The system architecture is built on a full-stack serverless model on AWS, focusing on automatic scalability, multi-layer security and cost optimization. All frontend – backend – data – AI – security components operate in a private environment, connected through VPC, PrivateLink and AWS management services\nYou will deploy seven CDK stacks linked together to create a scalable, secure and cost-optimized application:\nFrontend Layer – Deploy the interface on Amplify and distribute content via CloudFront.\nRouting \u0026amp; Protection – Protect access with Route 53, WAF and ACM SSL certificates.\nAuthentication Layer – Create a Cognito User Pool and integrate authentication for API Gateway.\nAPI Layer – Build a private API Gateway to securely communicate with the backend.\nCompute Layer – Run business logic using Lambda functions inside a private VPC.\nStorage Layer – Store static data and uploads on S3 via VPC Endpoint.\nData Layer – Run RDS in a private subnet and control access using IAM/SG.\nAI Layer – Integrate Amazon Bedrock to handle AI tasks via PrivateLink.\nSecurity \u0026amp; Observability – Monitor the entire system using CloudWatch, send alerts via SNS and manage security using IAM.\nContent Workshop Overview Setup Environment CDK Bootstrap Configure Infrastructure Stacks Configure API \u0026amp; Lambda Deploy Backend Services Test Endpoints End-to-End Push to GitLab Clean up "
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/1-worklog/1.5-week5/",
	"title": "Week 5 Worklog",
	"tags": [],
	"description": "",
	"content": "Week 5 Objectives: Begin shaping the system architecture for the e-commerce clothing website project. Research and design the system architecture integrated with AWS services. Visualize and document the project architecture using appropriate tools. Tasks to be carried out this week: Day Task Start Date Completion Date Reference Material 1 - Review the project’s functional requirements.\n- Identify system modules and backend responsibilities. 06/10/2025 06/10/2025 Internal notes 2 - Research common web architectural models (3-tier, MVC, microservices, etc.). 07/10/2025 07/10/2025 AWS Documentation 3 - Learn AWS services used in the project:\n+ EC2\n+ RDS\n+ S3\n+ CloudFront\n+ CloudWatch 08/10/2025 08/10/2025 https://cloudjourney.awsstudygroup.com/ 4 - Design and draw the system architecture diagram for the e-commerce project integrating AWS services. 09/10/2025 09/10/2025 draw.io 5 - Finalize and document the AWS-integrated architecture for group discussion and refinement. 10/10/2025 10/10/2025 Team meeting notes Week 5 Achievements: Understood the importance of system architecture in developing scalable web applications. Learned how to combine core AWS services (EC2, RDS, S3, CloudFront, CloudWatch) in an integrated architecture. Designed and drew the architecture diagram for the clothing e-commerce website with AWS integration. Defined how backend services interact with AWS for data storage, deployment, and monitoring. Documented the initial architecture for future implementation and team review. "
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/5-workshop/5.06-deploy-backend/",
	"title": "Deploy Backend Services",
	"tags": [],
	"description": "",
	"content": "Overview Dự án OJT E-commerce sử dụng kiến trúc 2-step deployment: Infrastructure (CDK) và Lambda Code (riêng biệt). Trong bước này, bạn sẽ deploy cả infrastructure và Lambda code.\nDeployment Architecture ┌─────────────────────────────────────────────────────────────┐\r│ 2-Step Deployment │\r├─────────────────────────────────────────────────────────────┤\r│ Step 1: Deploy Infrastructure (CDK) │\r│ ├─ NetworkStack: VPC, Subnets, NAT Gateway │\r│ ├─ StorageStack: S3 Buckets │\r│ ├─ AuthStack: Cognito (optional) │\r│ ├─ DatabaseStack: RDS SQL Server │\r│ ├─ ApiStack: API Gateway + Placeholder Lambda │\r│ ├─ FrontendStack: S3 + CloudFront │\r│ └─ MonitoringStack: CloudWatch │\r├─────────────────────────────────────────────────────────────┤\r│ Step 2: Deploy Lambda Code │\r│ └─ 11 Lambda Modules (63 APIs) → Update function code │\r└─────────────────────────────────────────────────────────────┘ Lambda Modules (11 modules - 63 APIs) Module Functions Description Auth 4 Login, Signup, Logout, Me Products 12 CRUD, Search, Filter ProductDetails 7 CRUD, Images Cart 6 Add, Get, Update, Remove Orders 9 CRUD, COD, Status Categories 6 CRUD, Search Brands 5 CRUD Banners 7 CRUD, Toggle Ratings 3 Get, Stats, Create Users 3 GetAll, GetById, Update Images 1 Upload to S3 Step 1: Deploy Infrastructure (CDK) 1.1 Navigate to Infrastructure Directory cd OJT_infrastructure 1.2 Install Dependencies npm install 1.3 Build TypeScript npm run build 1.4 Deploy Core Stacks # Deploy Network, Storage, Auth, Database stacks npm run deploy:core Expected output:\nOJT-NetworkStack\rOJT-StorageStack\rOJT-AuthStack\rOJT-DatabaseStack\rOutputs:\rOJT-NetworkStack.VpcId = vpc-0123456789abcdef0\rOJT-DatabaseStack.DbEndpoint = ojt-database.xxx.ap-southeast-1.rds.amazonaws.com\rOJT-StorageStack.ImagesBucketName = ojt-ecommerce-images-123456789012 Deploy time: ~15-20 minutes (RDS takes longest)\nScreenshot: CDK deploying core stacks\n1.5 Deploy API Stack # Deploy API Gateway + Placeholder Lambda npm run deploy:api Expected output:\n✅ OJT-ApiStack\rOutputs:\rOJT-ApiStack.ApiUrl = https://xxxxxxxxxx.execute-api.ap-southeast-1.amazonaws.com/prod\rOJT-ApiStack.AuthModuleName = OJT-Ecommerce-AuthModule\rOJT-ApiStack.ProductsModuleName = OJT-Ecommerce-ProductsModule\r... Deploy time: ~3-5 minutes\nScreenshot: CDK deploying API stack\n1.6 Verify CDK Deployment # List all deployed stacks aws cloudformation list-stacks ` --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE ` --query \u0026#34;StackSummaries[?contains(StackName, \u0026#39;OJT\u0026#39;)].StackName\u0026#34; ` --output table Expected output:\n---------------------------------\r| ListStacks |\r+-------------------------------+\r| OJT-NetworkStack |\r| OJT-StorageStack |\r| OJT-AuthStack |\r| OJT-DatabaseStack |\r| OJT-ApiStack |\r+-------------------------------+ Step 2: Deploy Lambda Code Sau khi CDK deploy xong, Lambda functions có placeholder code. Bây giờ deploy actual code.\n2.1 Navigate to Lambda Directory cd ..\\OJT_lambda 2.2 Install Dependencies # Install main dependencies npm install # Install all module dependencies npm run install:all 2.3 Configure Environment # Copy environment template copy .env.example .env # Edit .env with CDK outputs notepad .env Update .env with values from CDK outputs:\n# AWS Configuration AWS_REGION=ap-southeast-1 AWS_ACCOUNT_ID=123456789012 # Database (from OJT-DatabaseStack outputs) DB_HOST=ojt-database.xxx.ap-southeast-1.rds.amazonaws.com DB_NAME=demoaws DB_SECRET_ARN=arn:aws:secretsmanager:ap-southeast-1:123456789012:secret:OJT/RDS/Credentials # JWT JWT_SECRET=your-jwt-secret-key JWT_EXPIRES_IN=7d # S3 (from OJT-StorageStack outputs) S3_IMAGES_BUCKET=ojt-ecommerce-images-123456789012 2.4 Build Lambda Packages # Build all Lambda packages npm run build Expected output:\nBuilding auth module... Done\rBuilding products module... Done\rBuilding product-details module... Done\rBuilding cart module... Done\rBuilding orders module... Done\rBuilding categories module... Done\rBuilding brands module... Done\rBuilding banners module... Done\rBuilding ratings module... Done\rBuilding users module... Done\rBuilding images module... Done\rBuild completed! ZIP files in build/ directory. Build creates:\nbuild/\r├── auth.zip (~500 KB)\r├── products.zip (~600 KB)\r├── product-details.zip (~550 KB)\r├── cart.zip (~450 KB)\r├── orders.zip (~500 KB)\r├── categories.zip (~400 KB)\r├── brands.zip (~350 KB)\r├── banners.zip (~400 KB)\r├── ratings.zip (~350 KB)\r├── users.zip (~400 KB)\r└── images.zip (~300 KB) 2.5 Deploy Lambda Code # Deploy all Lambda functions npm run deploy Expected output:\nDeploying auth module to OJT-Ecommerce-AuthModule... Done\rDeploying products module to OJT-Ecommerce-ProductsModule... Done\rDeploying product-details module to OJT-Ecommerce-ProductDetailsModule... Done\rDeploying cart module to OJT-Ecommerce-CartModule... Done\rDeploying orders module to OJT-Ecommerce-OrdersModule... Done\rDeploying categories module to OJT-Ecommerce-CategoriesModule... Done\rDeploying brands module to OJT-Ecommerce-BrandsModule... Done\rDeploying banners module to OJT-Ecommerce-BannersModule... Done\rDeploying ratings module to OJT-Ecommerce-RatingsModule... Done\rDeploying users module to OJT-Ecommerce-UsersModule... Done\rDeploying images module to OJT-Ecommerce-ImagesModule... Done\rAll Lambda functions deployed successfully! Deploy time: ~1-2 minutes\nScreenshot: Lambda code deployment\nStep 3: Verify Lambda Deployment 3.1 List Lambda Functions aws lambda list-functions ` --query \u0026#34;Functions[?contains(FunctionName, \u0026#39;OJT-Ecommerce\u0026#39;)].{Name:FunctionName,Runtime:Runtime,Updated:LastModified}\u0026#34; ` --output table Expected output:\n--------------------------------------------------------------------\r| ListFunctions |\r+----------------------------------+------------+------------------+\r| Name | Runtime | Updated |\r+----------------------------------+------------+------------------+\r| OJT-Ecommerce-AuthModule | nodejs20.x | 2025-12-09T... |\r| OJT-Ecommerce-ProductsModule | nodejs20.x | 2025-12-09T... |\r| OJT-Ecommerce-ProductDetailsModule | nodejs20.x | 2025-12-09T...|\r| OJT-Ecommerce-CartModule | nodejs20.x | 2025-12-09T... |\r| OJT-Ecommerce-OrdersModule | nodejs20.x | 2025-12-09T... |\r| OJT-Ecommerce-CategoriesModule | nodejs20.x | 2025-12-09T... |\r| OJT-Ecommerce-BrandsModule | nodejs20.x | 2025-12-09T... |\r| OJT-Ecommerce-BannersModule | nodejs20.x | 2025-12-09T... |\r| OJT-Ecommerce-RatingsModule | nodejs20.x | 2025-12-09T... |\r| OJT-Ecommerce-UsersModule | nodejs20.x | 2025-12-09T... |\r| OJT-Ecommerce-ImagesModule | nodejs20.x | 2025-12-09T... |\r+----------------------------------+------------+------------------+ 3.2 Check Function Configuration # Check Auth Module configuration aws lambda get-function-configuration ` --function-name OJT-Ecommerce-AuthModule ` --query \u0026#39;{Runtime:Runtime,Handler:Handler,Timeout:Timeout,Memory:MemorySize}\u0026#39; Expected output:\n{ \u0026#34;Runtime\u0026#34;: \u0026#34;nodejs20.x\u0026#34;, \u0026#34;Handler\u0026#34;: \u0026#34;index.handler\u0026#34;, \u0026#34;Timeout\u0026#34;: 30, \u0026#34;Memory\u0026#34;: 128 } 3.3 Verify Code Updated # Check code SHA256 (changes when code updates) aws lambda get-function ` --function-name OJT-Ecommerce-AuthModule ` --query \u0026#39;Configuration.CodeSha256\u0026#39; Step 4: Test Lambda Functions 4.1 Test Auth Login # Invoke Auth Module aws lambda invoke ` --function-name OJT-Ecommerce-AuthModule ` --payload \u0026#39;{\\\u0026#34;httpMethod\\\u0026#34;:\\\u0026#34;POST\\\u0026#34;,\\\u0026#34;path\\\u0026#34;:\\\u0026#34;/auth/login\\\u0026#34;,\\\u0026#34;body\\\u0026#34;:\\\u0026#34;{\\\\\\\u0026#34;email\\\\\\\u0026#34;:\\\\\\\u0026#34;test@test.com\\\\\\\u0026#34;,\\\\\\\u0026#34;password\\\\\\\u0026#34;:\\\\\\\u0026#34;Test123!\\\\\\\u0026#34;}\\\u0026#34;}\u0026#39; ` response.json # Check response Get-Content response.json 4.2 Test Products List # Invoke Products Module aws lambda invoke ` --function-name OJT-Ecommerce-ProductsModule ` --payload \u0026#39;{\\\u0026#34;httpMethod\\\u0026#34;:\\\u0026#34;GET\\\u0026#34;,\\\u0026#34;path\\\u0026#34;:\\\u0026#34;/products\\\u0026#34;,\\\u0026#34;queryStringParameters\\\u0026#34;:{\\\u0026#34;page\\\u0026#34;:\\\u0026#34;1\\\u0026#34;,\\\u0026#34;limit\\\u0026#34;:\\\u0026#34;10\\\u0026#34;}}\u0026#39; ` response.json # Check response Get-Content response.json 4.3 Test via API Gateway # Get API URL $apiUrl = aws cloudformation describe-stacks ` --stack-name OJT-ApiStack ` --query \u0026#39;Stacks[0].Outputs[?OutputKey==`ApiUrl`].OutputValue\u0026#39; ` --output text # Test products endpoint Invoke-RestMethod -Uri \u0026#34;$apiUrl/products\u0026#34; -Method Get Step 5: Check CloudWatch Logs 5.1 Tail Logs Real-time # Tail Auth Module logs aws logs tail /aws/lambda/OJT-Ecommerce-AuthModule --follow 5.2 View Recent Logs # View last 10 minutes aws logs tail /aws/lambda/OJT-Ecommerce-AuthModule --since 10m 5.3 Search for Errors # Search for errors aws logs filter-log-events ` --log-group-name /aws/lambda/OJT-Ecommerce-AuthModule ` --filter-pattern \u0026#34;ERROR\u0026#34; Screenshot: CloudWatch Logs showing Lambda execution\nStep 6: Deploy Frontend \u0026amp; Monitoring (Optional) 6.1 Deploy Frontend Stack cd ..\\OJT_infrastructure npm run deploy:frontend 6.2 Deploy Monitoring Stack npm run deploy:monitoring Deployment Summary Time Estimates Step Time Notes CDK Deploy Core 15-20 min RDS takes longest CDK Deploy API 3-5 min API Gateway + Lambda Lambda Build 1-2 min ZIP packages Lambda Deploy 1-2 min Update function code Total ~25 min First deployment Update Lambda Code Only Khi chỉ thay đổi Lambda code (không thay đổi infrastructure):\ncd OJT_lambda # Build and deploy (skip CDK) npm run build npm run deploy # Time: ~2-3 minutes Deployment Checklist Infrastructure (CDK) NetworkStack deployed (VPC, Subnets, NAT Gateway) StorageStack deployed (S3 Buckets) AuthStack deployed (Cognito - optional) DatabaseStack deployed (RDS SQL Server) ApiStack deployed (API Gateway + Placeholder Lambda) Lambda Code Dependencies installed (npm install + npm run install:all) Environment configured (.env file) Lambda packages built (npm run build) Lambda code deployed (npm run deploy) Verification All 11 Lambda functions listed Runtime: nodejs20.x Code SHA256 updated Test invocations successful API Gateway responding CloudWatch logs showing executions Troubleshooting Issue: CDK Deploy Fails # Check AWS credentials aws sts get-caller-identity # Check CDK version cdk --version # Clean and rebuild Remove-Item -Recurse -Force node_modules, cdk.out npm install npm run build Issue: Lambda Deploy Fails # Check function exists aws lambda list-functions | Select-String \u0026#34;OJT-Ecommerce\u0026#34; # Check ZIP file created Get-ChildItem build/*.zip # Rebuild and redeploy npm run build npm run deploy Issue: Function Timeout # Increase timeout aws lambda update-function-configuration ` --function-name OJT-Ecommerce-AuthModule ` --timeout 60 Issue: Database Connection Error # Verify RDS endpoint aws rds describe-db-instances ` --db-instance-identifier ojt-database ` --query \u0026#39;DBInstances[0].Endpoint\u0026#39; # Check Security Group allows Lambda aws ec2 describe-security-groups ` --filters \u0026#34;Name=group-name,Values=*OJT*RDS*\u0026#34; Next Steps Backend đã deployed thành công! Tiếp theo:\nTest Endpoints: Verify tất cả 63 API endpoints → Deploy Frontend: React application → Monitor: CloudWatch dashboards → "
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/6-self-evaluation/",
	"title": "Self-Assessment",
	"tags": [],
	"description": "",
	"content": "During my internship at Amazon Web Services Vietnam Co., Ltd. from 8/9/2025 to 12/9/2025, I had the opportunity to apply my academic knowledge in a real-world professional setting while gaining practical experience.\nI participated in the First Cloud Journey program, which strengthened my communication abilities, enhanced my financial management skills, and expanded my understanding of AWS services and cloud computing.\nIn terms of professionalism, I consistently worked to complete all assigned tasks to a high standard, followed workplace guidelines, and actively collaborated with colleagues to improve team efficiency.\nNo. Criteria Description Good Fair Avg 1 Professional Knowledge \u0026amp; Skills Correctly understands the field, applies to practice, proficient with tools, high work quality ✅ ☐ ☐ 2 Learning Ability Absorbs new knowledge quickly, proactive in learning ☐ ✅ ☐ 3 Proactivity (Initiative) Self-starts tasks, does not wait for assignment ✅ ☐ ☐ 4 Sense of Responsibility Completes on time, ensures quality ✅ ☐ ☐ 5 Discipline Adheres to punctuality, regulations, and work processes ☐ ✅ ☐ 6 Progressive Spirit Willing to receive feedback and improve oneself ✅ ☐ ☐ 7 Communication Presents ideas clearly, reports work coherently ☐ ✅ ☐ 8 Teamwork Cooperates effectively with colleagues, participates actively in team activities ✅ ☐ ☐ 9 Professionalism Respects colleagues, partners, and the work environment ✅ ☐ ☐ 10 Problem-solving Skills Identifies problems, offers suitable solutions, possesses creative thinking ☐ ✅ ☐ 11 Contribution to Team/Project Work effectiveness, proposes new ideas, recognized by the team ☐ ✅ ☐ 12 Overall Assessment General evaluation of the entire internship process ☐ ✅ ☐ Needs Improvement Improve self-discipline and strictly comply with the company’s regulations. Enhance problem-solving thinking. Learn to handle situations more quickly and safely. Set clearer goals "
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/1-worklog/1.6-week6/",
	"title": "Week 6 Worklog",
	"tags": [],
	"description": "",
	"content": "Week 6 Objectives: Implement and test backend API endpoints for the clothing e-commerce website. Integrate AWS S3 for file storage and manage product images. Set up CI/CD pipeline for automated deployment. Tasks to be carried out this week: Day Task Start Date Completion Date Reference Material 1 - Implement product CRUD API endpoints - Test API using Postman or Insomnia - Validate request/response data 13/10/2025 13/10/2025 Spring Boot Documentation 2 - Set up AWS S3 bucket for product images - Configure bucket policies and CORS - Implement image upload/download functionality 14/10/2025 14/10/2025 AWS S3 Documentation 3 - Integrate file upload with product creation - Handle image resizing and optimization - Test image upload flow end-to-end 15/10/2025 15/10/2025 ImageIO, AWS SDK Documentation 4 - Set up GitHub Actions for CI/CD - Configure automated testing - Create deployment workflow 16/10/2025 16/10/2025 GitHub Actions Documentation 5 - Deploy application to AWS EC2 - Configure load balancer and auto-scaling - Set up monitoring with CloudWatch 17/10/2025 17/10/2025 AWS EC2, CloudWatch Documentation Week 6 Achievements: Successfully implemented complete CRUD operations for product management. Integrated AWS S3 for secure and scalable image storage. Configured proper bucket policies for secure file access. Built automated CI/CD pipeline using GitHub Actions. Deployed application to AWS EC2 with proper monitoring. Implemented image optimization to improve performance. Set up automated testing pipeline to ensure code quality. Configured CloudWatch for application monitoring and alerting. "
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/5-workshop/5.07-test-endpoints/",
	"title": "Test Endpoints End-to-End",
	"tags": [],
	"description": "",
	"content": "Overview Sau khi deploy backend thành công, bạn cần test tất cả API endpoints để đảm bảo hệ thống hoạt động đúng. Workshop này hướng dẫn chi tiết cách test từng module của hệ thống OJT E-commerce.\nAPI Architecture API Gateway (REST API)\r↓\r┌─────────────────────────────────────────────────────────────────┐\r│ 11 Lambda Modules (63 APIs) │\r├─────────┬─────────┬─────────┬─────────┬─────────┬───────────────┤\r│ Auth │Products │ Cart │ Orders │Categories│ Brands │\r│(4 APIs) │(12 APIs)│(6 APIs) │(9 APIs) │ (6 APIs) │ (5 APIs) │\r├─────────┼─────────┼─────────┼─────────┼─────────┼───────────────┤\r│ Banners │ Ratings │ Users │ Images │ Product │ │\r│(7 APIs) │(3 APIs) │(3 APIs) │(1 API) │ Details │ │\r│ │ │ │ │(7 APIs) │ │\r└─────────┴─────────┴─────────┴─────────┴─────────┴───────────────┘\r↓\rRDS SQL Server (via Secrets Manager) Step 1: Get API Endpoint 1. Get API URL from CloudFormation Outputs\n# Get API endpoint from API Stack $API_URL = aws cloudformation describe-stacks ` --stack-name OJT-ApiStack ` --query \u0026#39;Stacks[0].Outputs[?OutputKey==`ApiUrl`].OutputValue\u0026#39; ` --output text Write-Host \u0026#34;API Endpoint: $API_URL\u0026#34; # Output: https://xxxxxxxxxx.execute-api.ap-southeast-1.amazonaws.com/prod 2. Setup Environment Variables\n# Set API endpoint for PowerShell session $API_URL = \u0026#34;https://xxxxxxxxxx.execute-api.ap-southeast-1.amazonaws.com/prod\u0026#34; Write-Host \u0026#34;API Endpoint configured: $API_URL\u0026#34; Step 2: Test Authentication APIs 2.1 Test User Signup # POST /auth/signup $signupBody = @{ email = \u0026#34;testuser@example.com\u0026#34; password = \u0026#34;Test123!\u0026#34; fullName = \u0026#34;Test User\u0026#34; phone = \u0026#34;+84901234567\u0026#34; } | ConvertTo-Json $response = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/auth/signup\u0026#34; ` -Method Post ` -ContentType \u0026#34;application/json\u0026#34; ` -Body $signupBody $response | ConvertTo-Json 2.2 Test User Login # POST /auth/login $loginBody = @{ email = \u0026#34;testuser@example.com\u0026#34; password = \u0026#34;Test123!\u0026#34; } | ConvertTo-Json $loginResponse = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/auth/login\u0026#34; ` -Method Post ` -ContentType \u0026#34;application/json\u0026#34; ` -Body $loginBody # Save JWT token for authenticated requests $TOKEN = $loginResponse.token Write-Host \u0026#34;JWT Token: $TOKEN\u0026#34; $loginResponse | ConvertTo-Json # Expected: { \u0026#34;token\u0026#34;: \u0026#34;eyJhbG...\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;userId\u0026#34;: 1, \u0026#34;email\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;Customer\u0026#34; } } 2.3 Test Get Current User # GET /auth/me (requires authentication) $headers = @{ \u0026#34;Authorization\u0026#34; = \u0026#34;Bearer $TOKEN\u0026#34; } $meResponse = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/auth/me\u0026#34; ` -Method Get ` -Headers $headers $meResponse | ConvertTo-Json # Expected: { \u0026#34;user\u0026#34;: { \u0026#34;userId\u0026#34;: 1, \u0026#34;email\u0026#34;: \u0026#34;testuser@example.com\u0026#34;, \u0026#34;fullName\u0026#34;: \u0026#34;Test User\u0026#34; } } Step 3: Test Products APIs 3.1 Get All Products # GET /products $products = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/products?page=1\u0026amp;limit=10\u0026#34; ` -Method Get Write-Host \u0026#34;Found $($products.total) products\u0026#34; $products | ConvertTo-Json -Depth 3 3.2 Get Product Detail # GET /products/detail/{id} $productId = 1 $product = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/products/detail/$productId\u0026#34; ` -Method Get $product | ConvertTo-Json -Depth 3 3.3 Search Products # GET /products/search?q=keyword $searchResults = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/products/search?q=phone\u0026#34; ` -Method Get $searchResults | ConvertTo-Json -Depth 3 3.4 Get Best Selling Products # GET /products/best-selling $bestSelling = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/products/best-selling?limit=10\u0026#34; ` -Method Get $bestSelling | ConvertTo-Json -Depth 3 3.5 Get Newest Products # GET /products/newest $newest = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/products/newest?limit=10\u0026#34; ` -Method Get $newest | ConvertTo-Json -Depth 3 3.6 Get Products by Category # GET /products/category/{id} $categoryId = 1 $categoryProducts = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/products/category/$categoryId\u0026#34; ` -Method Get $categoryProducts | ConvertTo-Json -Depth 3 3.7 Get Products by Brand # GET /products/brand/{id} $brandId = 1 $brandProducts = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/products/brand/$brandId\u0026#34; ` -Method Get $brandProducts | ConvertTo-Json -Depth 3 Step 4: Test Cart APIs 4.1 Add to Cart # POST /cart (requires authentication) $cartBody = @{ productDetailId = 1 quantity = 2 } | ConvertTo-Json $cartResponse = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/cart\u0026#34; ` -Method Post ` -Headers $headers ` -ContentType \u0026#34;application/json\u0026#34; ` -Body $cartBody $cartResponse | ConvertTo-Json 4.2 Get My Cart # GET /cart/me $myCart = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/cart/me\u0026#34; ` -Method Get ` -Headers $headers $myCart | ConvertTo-Json -Depth 3 4.3 Update Cart Item # PUT /cart/{id} $cartItemId = 1 $updateBody = @{ quantity = 3 } | ConvertTo-Json $updateResponse = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/cart/$cartItemId\u0026#34; ` -Method Put ` -Headers $headers ` -ContentType \u0026#34;application/json\u0026#34; ` -Body $updateBody $updateResponse | ConvertTo-Json 4.4 Get Cart Count # GET /cart/count $cartCount = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/cart/count\u0026#34; ` -Method Get ` -Headers $headers Write-Host \u0026#34;Cart items: $($cartCount.count)\u0026#34; 4.5 Remove Cart Item # DELETE /cart/{id} Invoke-RestMethod ` -Uri \u0026#34;$API_URL/cart/$cartItemId\u0026#34; ` -Method Delete ` -Headers $headers Write-Host \u0026#34;Cart item removed\u0026#34; Step 5: Test Orders APIs 5.1 Create Order (COD) # POST /orders/create-cod $orderBody = @{ shippingAddress = \u0026#34;123 Test Street, District 1, Ho Chi Minh City\u0026#34; phone = \u0026#34;+84901234567\u0026#34; note = \u0026#34;Please call before delivery\u0026#34; } | ConvertTo-Json $orderResponse = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/orders/create-cod\u0026#34; ` -Method Post ` -Headers $headers ` -ContentType \u0026#34;application/json\u0026#34; ` -Body $orderBody $ORDER_ID = $orderResponse.orderId Write-Host \u0026#34;Order created: $ORDER_ID\u0026#34; $orderResponse | ConvertTo-Json 5.2 Get Order Details # GET /orders/{id}/details $orderDetails = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/orders/$ORDER_ID/details\u0026#34; ` -Method Get ` -Headers $headers $orderDetails | ConvertTo-Json -Depth 3 5.3 Get User Orders # GET /orders/user/{userId} $userId = 1 $userOrders = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/orders/user/$userId\u0026#34; ` -Method Get ` -Headers $headers $userOrders | ConvertTo-Json -Depth 3 5.4 Update Order Status (Admin) # PATCH /orders/{id}/status $statusBody = @{ status = \u0026#34;Processing\u0026#34; } | ConvertTo-Json $statusResponse = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/orders/$ORDER_ID/status\u0026#34; ` -Method Patch ` -Headers $headers ` -ContentType \u0026#34;application/json\u0026#34; ` -Body $statusBody $statusResponse | ConvertTo-Json Step 6: Test Categories APIs 6.1 Get All Categories # GET /categories $categories = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/categories\u0026#34; ` -Method Get $categories | ConvertTo-Json -Depth 3 6.2 Get Category by ID # GET /categories/{id} $categoryId = 1 $category = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/categories/$categoryId\u0026#34; ` -Method Get $category | ConvertTo-Json 6.3 Search Categories # GET /categories/search?q=keyword $categorySearch = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/categories/search?q=phone\u0026#34; ` -Method Get $categorySearch | ConvertTo-Json Step 7: Test Brands APIs 7.1 Get All Brands # GET /brands $brands = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/brands\u0026#34; ` -Method Get $brands | ConvertTo-Json -Depth 3 7.2 Get Brand by ID # GET /brands/{id} $brandId = 1 $brand = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/brands/$brandId\u0026#34; ` -Method Get $brand | ConvertTo-Json Step 8: Test Banners APIs 8.1 Get All Banners # GET /banners $banners = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/banners\u0026#34; ` -Method Get $banners | ConvertTo-Json -Depth 3 8.2 Get Active Banners # GET /banners?active=true $activeBanners = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/banners?active=true\u0026#34; ` -Method Get $activeBanners | ConvertTo-Json -Depth 3 Step 9: Test Ratings APIs 9.1 Get Product Ratings # GET /ratings/product/{id} $productId = 1 $ratings = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/ratings/product/$productId\u0026#34; ` -Method Get $ratings | ConvertTo-Json -Depth 3 9.2 Get Rating Stats # GET /ratings/product/{id}/stats $ratingStats = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/ratings/product/$productId/stats\u0026#34; ` -Method Get $ratingStats | ConvertTo-Json # Expected: { \u0026#34;averageRating\u0026#34;: 4.5, \u0026#34;totalRatings\u0026#34;: 10, \u0026#34;distribution\u0026#34;: { \u0026#34;5\u0026#34;: 5, \u0026#34;4\u0026#34;: 3, \u0026#34;3\u0026#34;: 2 } } 9.3 Create Rating # POST /ratings $ratingBody = @{ productId = 1 rating = 5 comment = \u0026#34;Great product! Highly recommended.\u0026#34; } | ConvertTo-Json $ratingResponse = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/ratings\u0026#34; ` -Method Post ` -Headers $headers ` -ContentType \u0026#34;application/json\u0026#34; ` -Body $ratingBody $ratingResponse | ConvertTo-Json Step 10: Test Users APIs (Admin) 10.1 Get All Users # GET /users (Admin only) $users = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/users\u0026#34; ` -Method Get ` -Headers $headers $users | ConvertTo-Json -Depth 3 10.2 Get User by ID # GET /users/{id} $userId = 1 $user = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/users/$userId\u0026#34; ` -Method Get ` -Headers $headers $user | ConvertTo-Json 10.3 Update User Profile # PUT /users/profile/{id} $profileBody = @{ fullName = \u0026#34;Updated Name\u0026#34; phone = \u0026#34;+84909876543\u0026#34; address = \u0026#34;456 New Street, District 2\u0026#34; } | ConvertTo-Json $profileResponse = Invoke-RestMethod ` -Uri \u0026#34;$API_URL/users/profile/$userId\u0026#34; ` -Method Put ` -Headers $headers ` -ContentType \u0026#34;application/json\u0026#34; ` -Body $profileBody $profileResponse | ConvertTo-Json Step 11: Test Images Upload API 11.1 Upload Image # POST /images/upload # Note: This requires multipart/form-data # Using curl for file upload curl -X POST \u0026#34;$API_URL/images/upload\u0026#34; ` -H \u0026#34;Authorization: Bearer $TOKEN\u0026#34; ` -F \u0026#34;file=@D:\\test-image.jpg\u0026#34; ` -F \u0026#34;type=product\u0026#34; --- ### Step 12: Verify CloudWatch Logs #### 12.1 Check Lambda Logs ```powershell # Tail Auth Module logs aws logs tail /aws/lambda/OJT-Ecommerce-AuthModule --follow # Tail Products Module logs aws logs tail /aws/lambda/OJT-Ecommerce-ProductsModule --follow # View last 10 minutes aws logs tail /aws/lambda/OJT-Ecommerce-AuthModule --since 10m Testing Checklist Authentication APIs (4 endpoints) POST /auth/signup - User registration POST /auth/login - User login, get JWT token POST /auth/logout - User logout GET /auth/me - Get current user Products APIs (12 endpoints) GET /products - List all products GET /products/detail/{id} - Get product detail GET /products/search - Search products GET /products/best-selling - Best selling products GET /products/newest - Newest products GET /products/category/{id} - Products by category GET /products/brand/{id} - Products by brand GET /products/price-range - Products by price range POST /products - Create product (Admin) PUT /products/{id} - Update product (Admin) DELETE /products/{id} - Delete product (Admin) Cart APIs (6 endpoints) POST /cart - Add to cart GET /cart/me - Get my cart PUT /cart/{id} - Update cart item DELETE /cart/{id} - Remove cart item DELETE /cart - Clear cart GET /cart/count - Get cart count Orders APIs (9 endpoints) POST /orders - Create order POST /orders/create-cod - Create COD order GET /orders/{id}/details - Get order details GET /orders/user/{userId} - Get user orders GET /orders - Get all orders (Admin) PATCH /orders/{id}/status - Update order status DELETE /orders/{id} - Cancel order Categories APIs (6 endpoints) GET /categories - List all categories GET /categories/{id} - Get category by ID GET /categories/search - Search categories POST /categories - Create category (Admin) PUT /categories/{id} - Update category (Admin) DELETE /categories/{id} - Delete category (Admin) Brands APIs (5 endpoints) GET /brands - List all brands GET /brands/{id} - Get brand by ID POST /brands - Create brand (Admin) PUT /brands/{id} - Update brand (Admin) DELETE /brands/{id} - Delete brand (Admin) Banners APIs (7 endpoints) GET /banners - List all banners GET /banners/{id} - Get banner by ID GET /banners?active=true - Get active banners POST /banners - Create banner (Admin) PUT /banners/{id} - Update banner (Admin) DELETE /banners/{id} - Delete banner (Admin) PATCH /banners/{id}/toggle - Toggle banner (Admin) Ratings APIs (3 endpoints) GET /ratings/product/{id} - Get product ratings GET /ratings/product/{id}/stats - Get rating stats POST /ratings - Create rating Users APIs (3 endpoints) GET /users - Get all users (Admin) GET /users/{id} - Get user by ID PUT /users/profile/{id} - Update profile Images API (1 endpoint) POST /images/upload - Upload image Performance Benchmarks Expected Response Times:\nEndpoint Expected Time Notes POST /auth/login \u0026lt; 500ms JWT generation GET /products \u0026lt; 300ms Database query GET /products/detail/{id} \u0026lt; 200ms Single record POST /cart \u0026lt; 300ms Database write POST /orders/create-cod \u0026lt; 500ms Transaction GET /categories \u0026lt; 200ms Cached data POST /images/upload \u0026lt; 2s S3 upload "
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/7-feedback/",
	"title": "Sharing and Feedback",
	"tags": [],
	"description": "",
	"content": "Overall Evaluation 1. Working Environment\nThe working environment is very friendly and open. Team members at FCJ are always willing to help whenever I face difficulties, even outside of working hours. The workspace is clean and comfortable, which helps me stay focused. However, I think the company could organize more social events or team-bonding activities to help everyone connect better.\n2. Support from Mentor / Team Admin\nMy mentor provides very detailed guidance, explains clearly when I don’t understand, and always encourages me to ask questions. The admin team supports all necessary procedures, documents, and ensures I have what I need to work effectively. I really appreciate that my mentor allows me to try and solve problems on my own instead of giving the answer directly.\n3. Relevance of Work to Academic Major\nThe tasks I’m assigned are aligned with what I learned at university while also introducing me to new areas I haven\u0026rsquo;t explored before. This helps me reinforce my foundational knowledge while gaining more practical skills.\n4. Learning \u0026amp; Skill Development Opportunities\nDuring the internship, I learned many new skills such as using project management tools, teamwork skills, and professional communication in a corporate environment. My mentor also shared valuable real-world experiences that helped me shape my career path more clearly.\n5. Company Culture \u0026amp; Team Spirit\nThe company culture is very positive: everyone respects each other, works seriously, but maintains a cheerful atmosphere.. This made me feel like a true part of the team.\n6. Internship Policies / Benefits\nThe company provides an internship allowance and allows flexible working hours when needed. Additionally, being able to join internal training sessions is a great advantage.\nAdditional Questions – Answers What were you most satisfied with during the internship?\nWhat I was most satisfied with was being given real tasks and receiving helpful feedback that allowed me to improve significantly.\nWhat do you think the company should improve for future interns?\nThe company could organize more onboarding workshops and technical training in the first week so new interns can adapt quickly.\nIf recommending to a friend, would you suggest they intern here? Why or why not?\nYes. Because the learning environment is great, mentors are supportive, and interns are given real opportunities to handle practical tasks instead of minor or unrelated work.\nSuggestions \u0026amp; Expectations – Answers Do you have any suggestions to improve the internship experience?\nThere should be more weekly check-in sessions between mentors and interns to track progress and provide clearer guidance.\nWould you like to continue this program in the future?\nYes, because this internship has provided me with valuable knowledge and motivation to grow further.\nAny additional comments (free sharing):\nI’m truly grateful for this opportunity. The internship has helped me grow in both technical skills and soft skills. Thank you to everyone on the team for your support.\n"
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/1-worklog/1.7-week7/",
	"title": "Week 7 Worklog",
	"tags": [],
	"description": "",
	"content": "Week 7 Objectives: Enhance e-commerce platform with user authentication and authorization. Implement shopping cart and order management functionality. Set up database optimization and security measures. Tasks to be carried out this week: Day Task Start Date Completion Date Reference Material 1 - Implement JWT-based authentication system - Create user registration and login endpoints - Set up password encryption and validation 20/10/2025 20/10/2025 Spring Security Documentation 2 - Design and implement role-based access control - Create admin and customer user roles - Secure API endpoints with proper authorization 21/10/2025 21/10/2025 Spring Security, JWT Documentation 3 - Implement shopping cart functionality - Create cart session management - Handle add/remove/update cart items 22/10/2025 22/10/2025 Redis, Spring Session Documentation 4 - Build order management system - Create order placement and tracking - Implement order status workflow 23/10/2025 23/10/2025 Spring Boot, JPA Documentation 5 - Set up AWS RDS for production database - Configure database security groups - Implement database backup and monitoring 24/10/2025 24/10/2025 AWS RDS, CloudWatch Documentation Week 7 Achievements: Successfully implemented JWT-based authentication system with secure token management. Built comprehensive role-based access control for different user types. Created efficient shopping cart system with session management. Developed complete order management workflow from placement to fulfillment. Migrated database to AWS RDS with proper security configurations. Implemented automated backup strategies for data protection. Set up database monitoring and alerting through CloudWatch. Enhanced API security with proper authentication and authorization layers. "
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/5-workshop/5.08-push-gitlab/",
	"title": "Push to GitLab",
	"tags": [],
	"description": "",
	"content": "Overview Sau khi test thành công, bạn sẽ push code lên GitLab để version control và chuẩn bị cho CI/CD. Dự án OJT E-commerce có 3 phần chính cần quản lý: Infrastructure, Lambda, và Frontend.\nProject Structure OJT/\r├── OJT_infrastructure/ # CDK Infrastructure (TypeScript)\r├── OJT_lambda/ # Lambda Functions (JavaScript)\r├── OJT_frontendDev/ # Frontend (React + Vite)\r├── database/ # Database Scripts\r└── README.md # Project documentation Step 1: Initialize Git Repository 1. Navigate to Project Root\ncd D:\\AWS\\Src\\OJT 2. Check Git Status\n# Check if Git is already initialized git status # If not initialized: git init 3. Configure Git\n# Set your name and email git config user.name \u0026#34;Your Name\u0026#34; git config user.email \u0026#34;your.email@example.com\u0026#34; # Verify configuration git config --list Step 2: Create .gitignore 1. Create .gitignore File\n# Create .gitignore in project root @\u0026#34; # Dependencies node_modules/ package-lock.json # Build outputs dist/ build/ *.js.map cdk.out/ # Environment variables .env .env.local .env.*.local # AWS *.pem *.key # Deployment packages *.zip # Logs logs/ *.log npm-debug.log* # IDE .vscode/settings.json .idea/ *.swp *.swo # OS .DS_Store Thumbs.db # CDK cdk.context.json # TypeScript *.tsbuildinfo *.d.ts *.js !vite.config.js !eslint.config.js # Lambda build OJT_lambda/build/ \u0026#34;@ | Out-File -FilePath .gitignore -Encoding UTF8 2. Verify .gitignore\nGet-Content .gitignore Step 3: Stage and Commit Files 1. Add Files to Staging\n# Add all files git add . # Check what will be committed git status 2. Review Files to Commit\n# List files to be committed git diff --cached --name-only # Expected files: # OJT_infrastructure/ # OJT_lambda/ # OJT_frontendDev/ # database/ # README.md # .gitignore 3. Create Initial Commit\n# Commit with message git commit -m \u0026#34;Initial commit: OJT E-commerce infrastructure and backend\u0026#34; # Verify commit git log --oneline ### Step 4: Create GitLab Repository **1. Login to GitLab** Go to https://gitlab.com/ and login with your account. **2. Create New Project** 1. Click **\u0026#34;New project\u0026#34;** 2. Choose **\u0026#34;Create blank project\u0026#34;** 3. Fill in details: - Project name: `ojt-ecommerce` - Project slug: `ojt-ecommerce` - Visibility: **Private** (recommended) - Initialize with README: **No** (we already have code) 4. Click **\u0026#34;Create project\u0026#34;** **3. Copy Repository URL** https://gitlab.com/your-username/ojt-ecommerce.git\n---\r### Step 5: Add Remote and Push\r**1. Add GitLab Remote**\r```powershell\r# Add remote origin\rgit remote add origin https://gitlab.com/your-username/ojt-ecommerce.git\r# Verify remote\rgit remote -v 2. Push to GitLab\n# Push to main branch git push -u origin main # If your default branch is \u0026#39;master\u0026#39;: git branch -M main git push -u origin main 3. Enter Credentials\nWhen prompted:\nUsername: Your GitLab username Password: Your GitLab Personal Access Token (not password) Screenshot: Terminal showing successful push\nStep 6: Create Personal Access Token If you don\u0026rsquo;t have a Personal Access Token:\n1. Go to GitLab Settings\nClick your avatar → \u0026ldquo;Preferences\u0026rdquo; Go to \u0026ldquo;Access Tokens\u0026rdquo; in left sidebar 2. Create New Token\nToken name: OJT-Ecommerce-Token Expiration date: Set appropriate date Select scopes: read_repository write_repository Click \u0026ldquo;Create personal access token\u0026rdquo; 3. Save Token\nCopy and save the token securely. You won\u0026rsquo;t be able to see it again.\nStep 7: Verify Push on GitLab 1. Check Repository on GitLab\nGo to your repository: https://gitlab.com/your-username/ojt-ecommerce\n2. Verify Files\nCheck that all files are uploaded:\nOJT_infrastructure/ - CDK Infrastructure OJT_lambda/ - Lambda Functions OJT_frontendDev/ - Frontend database/ - Database Scripts README.md - Documentation .gitignore - Git ignore rules Step 8: Create Development Branch 1. Create dev Branch\n# Create and switch to dev branch git checkout -b dev # Push dev branch to GitLab git push -u origin dev 2. Set Default Branch (Optional)\nOn GitLab:\nGo to Settings → Repository Under Branch defaults, set dev as default branch Step 9: Setup Branch Protection (Optional) 1. Protect Main Branch\nOn GitLab:\nGo to Settings → Repository → Protected branches Add main branch: Allowed to merge: Maintainers Allowed to push: No one Require approval: Yes 2. Protect Dev Branch\nAdd dev branch with similar settings but allow developers to push.\nGit Workflow Summary 1. Create feature branch from dev\rgit checkout dev\rgit pull origin dev\rgit checkout -b feature/new-feature\r2. Make changes and commit\rgit add .\rgit commit -m \u0026#34;feat: Add new feature\u0026#34;\r3. Push to GitLab\rgit push -u origin feature/new-feature\r4. Create Merge Request on GitLab\rfeature/new-feature → dev\r5. Review and merge\r6. Deploy to dev environment\rcd OJT_lambda\rnpm run build\rnpm run deploy\r7. Test in dev environment\r8. Merge dev → main for production Commit Message Convention Follow conventional commits:\nfeat: Add user authentication\rfix: Fix login validation bug\rdocs: Update API documentation\rstyle: Format code with prettier\rrefactor: Refactor database queries\rtest: Add unit tests for auth\rchore: Update dependencies\rperf: Optimize product search query Examples:\ngit commit -m \u0026#34;feat: Add cart functionality\u0026#34; git commit -m \u0026#34;fix: Fix order total calculation\u0026#34; git commit -m \u0026#34;docs: Update README with deployment steps\u0026#34; Branch Naming Convention feature/add-cart-api\rfeature/user-authentication\rbugfix/fix-login-error\rbugfix/cart-quantity-issue\rhotfix/critical-security-patch\rrelease/v1.0.0 Troubleshooting Issue: Authentication Failed # Use Personal Access Token instead of password # When prompted for password, enter your token # Or configure credential helper git config --global credential.helper store Issue: Large Files Rejected # Check file sizes git ls-files -z | ForEach-Object { $size = (Get-Item $_).Length / 1MB if ($size -gt 1) { Write-Host \u0026#34;$_ : $size MB\u0026#34; } } # Add large files to .gitignore echo \u0026#34;*.zip\u0026#34; \u0026gt;\u0026gt; .gitignore git rm --cached *.zip git commit -m \u0026#34;Remove large files\u0026#34; Issue: Push Rejected (Non-Fast-Forward) # Pull latest changes first git pull origin main --rebase # Then push git push origin main Issue: Merge Conflicts # Update your branch git checkout feature/your-feature git fetch origin git merge origin/dev # Resolve conflicts in files # Then commit git add . git commit -m \u0026#34;Resolve merge conflicts\u0026#34; git push Repository Checklist Git initialized in project root .gitignore created with proper exclusions Initial commit created GitLab repository created Remote origin added Code pushed to GitLab Personal Access Token created (if needed) Files verified on GitLab Dev branch created Branch protection configured (optional) Next Steps "
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/1-worklog/1.8-week8/",
	"title": "Week 8 Worklog",
	"tags": [],
	"description": "",
	"content": "Week 8 Objectives: Implement payment integration and order processing system. Set up email notification service and real-time features. Optimize application performance and implement caching strategies. Tasks to be carried out this week: Day Task Start Date Completion Date Reference Material 1 - Integrate payment gateway (Stripe/PayPal) - Implement secure payment processing - Handle payment confirmation and failure scenarios 27/10/2025 27/10/2025 Stripe API, PayPal SDK Documentation 2 - Set up AWS SES for email notifications - Create email templates for orders - Implement order confirmation emails 28/10/2025 28/10/2025 AWS SES Documentation 3 - Implement real-time notifications using WebSocket - Set up order status updates - Create admin notification system 29/10/2025 29/10/2025 WebSocket, Spring WebSocket Documentation 4 - Set up Redis for caching - Implement product catalog caching - Add session caching for better performance 30/10/2025 30/10/2025 Redis, Spring Cache Documentation 5 - Optimize database queries - Implement pagination and filtering - Add search functionality with Elasticsearch 31/10/2025 31/10/2025 JPA, Elasticsearch Documentation Week 8 Achievements: Successfully integrated secure payment processing with multiple payment methods. Implemented comprehensive email notification system using AWS SES. Built real-time notification system for better user experience. Set up Redis caching to improve application performance significantly. Optimized database operations and implemented efficient search functionality. Created robust error handling for payment and order processing. Enhanced system scalability with proper caching strategies. Implemented monitoring for payment transactions and system performance. "
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/5-workshop/5.09-cleanup/",
	"title": "Cleanup",
	"tags": [],
	"description": "",
	"content": "Overview When you complete the workshop and no longer want to continue using it, delete all resources to avoid incurring charges.\nWarning: This process cannot be undone. All data will be permanently deleted.\nResources to Delete OJT E-commerce project includes:\nStack Resources Monthly Cost MonitoringStack CloudWatch Dashboard, Alarms ~$1.50 FrontendStack S3, CloudFront ~$1.50 ApiStack API Gateway, 11 Lambda functions ~$2 DatabaseStack RDS SQL Server, Secrets Manager ~$15 AuthStack Cognito User Pool $0 StorageStack S3 Buckets ~$1.25 NetworkStack VPC, NAT Gateway ~$23 Total ~$44/month Cleanup Order Must delete in reverse order of deployment:\n1. MonitoringStack\r2. FrontendStack\r3. ApiStack\r4. DatabaseStack\r5. AuthStack\r6. StorageStack\r7. NetworkStack\r8. CDK Bootstrap (optional) Step 1: Navigate to Infrastructure Directory cd D:\\AWS\\Src\\OJT\\OJT_infrastructure Step 2: Empty S3 Buckets S3 buckets must be emptied before deletion:\n# List all OJT buckets aws s3 ls | Select-String \u0026#34;ojt\u0026#34; # Empty Images bucket aws s3 rm s3://ojt-ecommerce-images-123456789012 --recursive # Empty Logs bucket aws s3 rm s3://ojt-ecommerce-logs-123456789012 --recursive # Empty Frontend bucket (if deployed) aws s3 rm s3://ojt-ecommerce-frontend-123456789012 --recursive Or use PowerShell script:\n# Get all OJT buckets and empty them $buckets = aws s3 ls | Select-String \u0026#34;ojt\u0026#34; | ForEach-Object { $_.ToString().Split()[-1] } foreach ($bucket in $buckets) { Write-Host \u0026#34;Emptying bucket: $bucket\u0026#34; -ForegroundColor Yellow aws s3 rm \u0026#34;s3://$bucket\u0026#34; --recursive Write-Host \u0026#34;Bucket emptied: $bucket\u0026#34; -ForegroundColor Green } Step 3: Delete CDK Stacks 3.1 Delete Monitoring Stack # Delete Monitoring stack npx cdk destroy OJT-MonitoringStack --force # Or with confirmation npx cdk destroy OJT-MonitoringStack # Type \u0026#39;y\u0026#39; to confirm 3.2 Delete Frontend Stack # Delete Frontend stack npx cdk destroy OJT-FrontendStack --force 3.3 Delete API Stack # Delete API stack (Lambda functions + API Gateway) npx cdk destroy OJT-ApiStack --force 3.4 Delete Database Stack # Delete Database stack (RDS SQL Server) # This takes 5-10 minutes npx cdk destroy OJT-DatabaseStack --force Note: RDS deletion creates a final snapshot by default.\n3.5 Delete Auth Stack # Delete Auth stack (Cognito) npx cdk destroy OJT-AuthStack --force 3.6 Delete Storage Stack # Delete Storage stack (S3 buckets) npx cdk destroy OJT-StorageStack --force 3.7 Delete Network Stack # Delete Network stack (VPC, NAT Gateway) # This takes 3-5 minutes npx cdk destroy OJT-NetworkStack --force Step 4: Delete All Stacks at Once (Alternative) # Delete all stacks in correct order npm run destroy # Or using CDK directly npx cdk destroy --all --force Expected output:\nOJT-MonitoringStack: destroying...\rOJT-MonitoringStack: destroyed\rOJT-FrontendStack: destroying...\rOJT-FrontendStack: destroyed\rOJT-ApiStack: destroying...\rOJT-ApiStack: destroyed\rOJT-DatabaseStack: destroying...\rOJT-DatabaseStack: destroyed\rOJT-AuthStack: destroying...\rOJT-AuthStack: destroyed\rOJT-StorageStack: destroying...\rOJT-StorageStack: destroyed\rOJT-NetworkStack: destroying...\rOJT-NetworkStack: destroyed Step 5: Verify All Stacks Deleted # List remaining stacks aws cloudformation list-stacks ` --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE ` --query \u0026#34;StackSummaries[?contains(StackName, \u0026#39;OJT\u0026#39;)].StackName\u0026#34; ` --output table # Should return empty or no OJT stacks Step 6: Delete CDK Bootstrap (Optional) ⚠️ Only do this if you\u0026rsquo;re done with CDK completely in this region:\n# Get CDK assets bucket name $BUCKET_NAME = aws s3 ls | Select-String \u0026#34;cdk-\u0026#34; | ForEach-Object { $_.ToString().Split()[-1] } # Empty CDK assets bucket aws s3 rm \u0026#34;s3://$BUCKET_NAME\u0026#34; --recursive # Delete CDK bootstrap stack aws cloudformation delete-stack --stack-name CDKToolkit # Wait for deletion aws cloudformation wait stack-delete-complete --stack-name CDKToolkit Write-Host \u0026#34;CDK Bootstrap deleted\u0026#34; -ForegroundColor Green Step 7: Verify Complete Cleanup 7.1 Check CloudFormation aws cloudformation list-stacks ` --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE ` | Select-String \u0026#34;OJT\u0026#34; # Should return nothing 7.2 Check S3 aws s3 ls | Select-String \u0026#34;ojt\u0026#34; # Should return nothing 7.3 Check Lambda aws lambda list-functions ` --query \u0026#34;Functions[?contains(FunctionName, \u0026#39;OJT\u0026#39;)].FunctionName\u0026#34; # Should return empty array 7.4 Check RDS aws rds describe-db-instances ` --query \u0026#34;DBInstances[?contains(DBInstanceIdentifier, \u0026#39;ojt\u0026#39;)].DBInstanceIdentifier\u0026#34; # Should return empty array 7.5 Check API Gateway aws apigateway get-rest-apis ` --query \u0026#34;items[?contains(name, \u0026#39;OJT\u0026#39;)].name\u0026#34; # Should return empty array 7.6 Check Cognito aws cognito-idp list-user-pools --max-results 10 ` --query \u0026#34;UserPools[?contains(Name, \u0026#39;OJT\u0026#39;)].Name\u0026#34; # Should return empty array 7.7 Check NAT Gateway aws ec2 describe-nat-gateways ` --filter \u0026#34;Name=state,Values=available\u0026#34; ` --query \u0026#34;NatGateways[].NatGatewayId\u0026#34; # Should not show OJT NAT Gateways Step 8: Delete RDS Snapshots (Optional) # List RDS snapshots aws rds describe-db-snapshots ` --query \u0026#34;DBSnapshots[?contains(DBSnapshotIdentifier, \u0026#39;ojt\u0026#39;)].DBSnapshotIdentifier\u0026#34; # Delete each snapshot aws rds delete-db-snapshot --db-snapshot-identifier ojt-database-final-snapshot Step 9: Delete CloudWatch Log Groups (Optional) # List log groups aws logs describe-log-groups ` --log-group-name-prefix /aws/lambda/OJT ` --query \u0026#34;logGroups[].logGroupName\u0026#34; # Delete each log group $logGroups = aws logs describe-log-groups ` --log-group-name-prefix /aws/lambda/OJT ` --query \u0026#34;logGroups[].logGroupName\u0026#34; ` --output text foreach ($logGroup in $logGroups.Split()) { Write-Host \u0026#34;Deleting log group: $logGroup\u0026#34; aws logs delete-log-group --log-group-name $logGroup } Cost After Cleanup Immediate:\nMost resources: $0/month RDS snapshots: ~$0.095/GB/month (if kept) After complete cleanup:\nEverything: $0/month Troubleshooting Cleanup Issue: S3 Bucket Deletion Fails # Force empty and delete aws s3 rb s3://bucket-name --force Issue: CloudFormation Stack Stuck in DELETE_IN_PROGRESS # Check stack events for errors aws cloudformation describe-stack-events ` --stack-name OJT-NetworkStack ` --max-items 10 # If stuck, wait or check for dependencies Issue: RDS Deletion Protection Enabled # Disable deletion protection aws rds modify-db-instance ` --db-instance-identifier ojt-database ` --no-deletion-protection ` --apply-immediately # Wait a few minutes, then retry delete Issue: VPC Has Dependencies # Check for remaining ENIs aws ec2 describe-network-interfaces ` --filters \u0026#34;Name=vpc-id,Values=vpc-xxxxxxxx\u0026#34; # Delete any remaining ENIs manually aws ec2 delete-network-interface --network-interface-id eni-xxxxxxxx Issue: NAT Gateway Still Exists # Delete NAT Gateway manually aws ec2 delete-nat-gateway --nat-gateway-id nat-xxxxxxxx # Release Elastic IP aws ec2 release-address --allocation-id eipalloc-xxxxxxxx Cleanup Checklist CDK Stacks MonitoringStack deleted FrontendStack deleted ApiStack deleted DatabaseStack deleted AuthStack deleted StorageStack deleted NetworkStack deleted AWS Resources All S3 buckets emptied and deleted No remaining Lambda functions No remaining RDS instances No remaining API Gateways No remaining Cognito User Pools No remaining NAT Gateways No remaining VPCs Optional Cleanup CDK Bootstrap deleted RDS snapshots deleted CloudWatch Log Groups deleted GitLab repository archived/deleted Verification CloudFormation shows no OJT stacks AWS Billing shows decreasing costs No unexpected charges Conclusion You have completed the OJT E-commerce workshop! You have learned:\nInfrastructure as Code with AWS CDK (TypeScript)\nServerless Architecture with Lambda and API Gateway\nRDS SQL Server database management\nVPC Design with public/private/isolated subnets\nS3 Storage for images and static files\nCloudFront CDN with Origin Access Control\nCognito Authentication (optional)\nJWT Authentication with custom Lambda\nCloudWatch Monitoring with dashboards and alarms\nCost Optimization strategies for serverless\nGitLab version control\n2-Step Deployment strategy (Infrastructure + Lambda code)\nTotal deployed:\n7 CDK stacks 11 Lambda modules (63 APIs) RDS SQL Server database VPC with NAT Gateway S3 buckets for storage CloudFront CDN CloudWatch monitoring Production-ready e-commerce platform Estimated monthly cost: ~$44/month (optimized)\nThank you for completing the workshop! 🎉\n"
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/1-worklog/1.9-week9/",
	"title": "Week 8 Worklog",
	"tags": [],
	"description": "",
	"content": "Week 9 Objectives: Continue learning and familiarizing yourself with AWS services Learn and implement projects Tasks to be carried out this week: Day Task Start Date Completion Date Reference Material 2 - Containerization with Docker - Container Orchestration with Amazon ECS - Container Orchestration with Amazon ECS 27/10/2025 27/10/2025 3 - CI/CD Pipeline with AWS CodePipeline - Automated Deployments with AWS CodePipeline - DevOps with AWS CodePipeline 28/10/2025 28/10/2025 https://cloudjourney.awsstudygroup.com/ 4 - Hybrid Storage with AWS Storage Gateway - Windows File Storage with Amazon FSx 29/10/2025 29/10/2025 https://cloudjourney.awsstudygroup.com/ 5 - Windows File Storage with Amazon FSx - Building Advanced Applications with Amazon DynamoDB 30/10/2025 30/10/2025 https://cloudjourney.awsstudygroup.com/ 6 - Workflow Orchestration with AWS Step Functions - Storage Performance Workshop 31/10/2025 31/10/2025 https://cloudjourney.awsstudygroup.com/ Week 9 Achievements: Containerization with Docker\nBuild and push Docker images for backend + frontend, deploy on EC2.\nCreate Docker network and launch containers, test applications via public IP.\nUse Docker Compose to manage stacks and redeploy the entire system quickly.\nContainer Orchestration with Amazon ECS\nUnderstand Amazon ECS architecture, create and manage ECS clusters.\nDefine ECS tasks and services, configure Application Load Balancer for load balancing.\nDeploy containerized applications on ECS, test deployment and clean up resources after completion.\nContainer Orchestration with Amazon ECS\nBuild containerized Spring Boot (Java 21) microservices and deploy to ECS Fargate.\nUse AWS CDK to create VPC + NAT Gateway, ECS Cluster, Load Balancer, and API Gateway.\nCreate DynamoDB using CDK to serve as a backend storage for service “products”.\nInstrument ECS service with AWS X‑Ray (add sidecar, declare Inspector, test trace).\nClean up resources after completing the workshop.\nCI/CD Pipeline with AWS CodePipeline\nSet up automated CI/CD for containers on Amazon ECS, using GitLab, GitHub or CodeBuild.\nDeploy integration workflow (build → deploy) to ECS Service, ensuring automatic application updates.\nMonitor containers with Container Insights + collect logs via FireLens, ensuring effective observation and debugging.\nClean up AWS resources after completion to optimize costs.\nAutomated Deployments with AWS CodePipeline\nSet up a CodePipeline pipeline integrating CodeCommit → CodeBuild → CodeDeploy to deploy Node.js applications to EC2.\nConfigure CodeDeploy Agent on EC2 (via Session Manager or User Data).\nDeploy the application in-place to EC2 instances, test after deployment.\nSet up infrastructure (VPC, Security Group, RDS if needed) to serve the pipeline.\nClean up AWS resources after completing the lab to save costs.\nDevOps with AWS CodePipeline\nCreate an IAM Role for CodeBuild to interact with the EKS cluster.\nConfigure aws-auth to allow CodeBuild to use kubectl with permissions on the cluster.\nSet up a CodePipeline pipeline using CloudFormation to automatically build + deploy sample services to EKS.\nTrigger new releases when changing code on GitHub → automatically update services on EKS.\nClean up all resources (deployment, stack, bucket) after the lab to avoid additional costs.\nHybrid Storage with AWS Storage Gateway\nCreate S3 bucket + initialize EC2 to use as Storage Gateway.\nConfigure AWS Storage Gateway, create SMB/NFS file share and mount on on-premises machine.\nSet up SMB access (guest) to share files from on-prem machine to S3.\nTest by creating files on mounted drive → files are synchronized to S3.\nClean up resources: delete Gateway, EC2, S3 bucket after completion.\nWindows File Storage with Amazon FSx\nDeploy FSx Windows File Server using CloudFormation in VPC.\nCreate and map SMB file shares on EC2 Windows, test with sample data.\nEnable shadow copies to save previous file versions \u0026amp; configure backup storage.\nEnable Continuous Access share to support HA for applications such as SQL Server.\nAdjust storage capacity and throughput according to needs; clean up resources after doing lab\nBuilding Advanced Applications with Amazon DynamoDB\nDo hands-on DynamoDB lab to understand the basics of querying, Streams, Global Tables and NoSQL data model.\nBuild advanced “design patterns” for DynamoDB (partitioning, GSI, adjacency list).\nDeploy global serverless applications with DynamoDB Global Tables.\nWorkflow Orchestration with AWS Step Functions\nDesign and implement state machine orchestration using Lambda: including task, branching (Choice) and parallel (Parallel).\nConfigure retry \u0026amp; catch errors when Lambda encounters problems for more sustainable workflow.\nUse token callback (waitForTaskToken) to allow pause/resume workflow.\nSet up debugging / logging, visualize workflow and clean up resources after lab completion Storage Performance Workshop\nInitialize resources via CloudFormation (EC2, Security Group) to run performance lab.\nOptimize S3 throughput, use parallel prefix, sync command, and upload multiple small files to increase TPS.\nOptimize EFS performance: configure IOPS, I/O size, multi-threading and choose appropriate performance mode.\nClean up resources after lab: delete S3 bucket, terminate EC2, delete CloudFormation stack.\n"
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/1-worklog/1.10-week10/",
	"title": "Week 10 Worklog",
	"tags": [],
	"description": "",
	"content": "Week 10 Objectives: Learn more about aws services Continue working on the project Tasks to be carried out this week: Day Task Start Date Completion Date Reference Material 2 - Serverless Backend with Lambda, S3, and DynamoDB - Frontend Development for Serverless APIs 03/11/2025 03/11/2025 3 - Deployment Automation with AWS SAM - User Authentication with Amazon Cognito 04/11/2025 04/11/2025 https://cloudjourney.awsstudygroup.com/ 4 - Custom Domains and SSL for Serverless Applications - Event Processing with SQS and SNS 05/11/2025 05/11/2025 https://cloudjourney.awsstudygroup.com/ 5 - CI/CD for Serverless Applications - Monitoring Serverless Applications - Building GraphQL APIs with AWS AppSync 06/11/2025 06/11/2025 https://cloudjourney.awsstudygroup.com/ 6 - Building Serverless APIs - Serverless Chat Application 07/11/2025 07/11/2025 https://cloudjourney.awsstudygroup.com/ Week 10Achievements: Frontend Development for Serverless APIs Build a web interface (frontend) to call API created by API Gateway + Lambda.\nDeploy front-end: can host static site (HTML/CSS/JS) connecting to serverless backend.\nDeploy Lambda function to handle request logic from API Gateway.\nConfigure API Gateway as endpoint for frontend: define route, HTTP method,…\nTest API with Postman: ensure API Gateway + Lambda runs correctly before frontend calls.\nTest frontend: web app calls API Gateway, receives results from Lambda and displays.\nDeployment Automation with AWS SAM Use AWS SAM (Serverless Application Model) to define serverless application via YAML file, then SAM will convert to CloudFormation when deploying.\nCreate and deploy front-end, Lambda function and API Gateway with SAM.\nTest API with Postman and frontend after deploying.\nUser Authentication with Amazon Cognito Create a Cognito User Pool to manage registration, login, email verification, password change, password reset.\nUse Identity Pool if you need to grant AWS Credentials (temporarily) to users to access services such as S3, DynamoDB.\nCreate API and Lambda: after the user authenticates via Cognito, Lambda handles the API request.\nFrontend: build login/registration UI, call Cognito API to log in and get token; then send token to API Gateway/Lambda.\nCustom Domains \u0026amp; SSL for Serverless Apps Use API Gateway to configure a custom domain name (“custom domain”) instead of the default hostname of API Gateway.\nUse Amazon Certificate Manager (ACM) to create or import SSL/TLS certificate for the domain, ensuring HTTPS.\nSelect custom domain type: edge-optimized (using CloudFront) or regional.\nConfigure Base Path Mapping to map domain + path to API Gateway stages.\nCreate DNS record (Route 53 or other DNS) to point domain to CloudFront distribution or endpoint provided by API Gateway.\nSSL and security: you can choose TLS security policy, ACM will manage certificate renewal. AWS Docs\n**Event Processing with SQS \u0026amp; SNS ** When users place an order, API sends messages to SQS queue to ensure “queue” to process the order.\nAt the same time, SNS is used to notify admin every time there is a new order.\nCreate Lambdas:\ncheckout_order to receive orders from API and push messages to SQS + publish SNS.\nhandle_order for admin to process orders: read from SQS, write orders to DynamoDB.\ndelete_order for admin to delete order: delete message in SQS.\norder_management for admin to view order list (using DynamoDB).\nArchitecture uses SQS for durability and asynchronous processing, SNS for fan-out notifications.\nCI/CD for Serverless Apps Use AWS SAM Pipelines to automate the process of building, packaging and deploying serverless applications.\nInitialize CI/CD pipeline: sam pipeline init to create pipeline configuration for AWS CodePipeline\nPipeline includes many stages: Source (Git), Build (using SAM CLI), Deploy (CloudFormation/SAM).\nUse build container image provided by AWS SAM to compile serverless app, helping reduce the effort of creating separate CI image.\nPipeline follows AWS best-practice pattern: supports multi-account, multi-region.\nMonitoring Serverless Applications Use CloudWatch Logs to debug Lambda: log invocations, errors, etc.\nCreate custom metrics in CloudWatch to monitor business or performance metrics.\nConfigure CloudWatch Alarms based on metrics to alert when there is an abnormal situation.\nUse AWS X-Ray to trace requests: draw service maps, see the path of requests and find bottlenecks.\n###Building GraphQL APIs with AWS AppSync\nUse AWS AppSync to create serverless GraphQL APIs, combined with AWS data sources such as DynamoDB, Lambda or Aurora Serverless.\nDefine GraphQL schema: type, query, mutation, subscription (if real-time required). AWS Docs\nConfigure resolvers:\nUse VTL mapping template to convert GraphQL requests into data source query operations.\nOr use Direct Lambda Resolver: Lambda handles GraphQL logic, avoiding the need to write VTL.\nIf using a relational database (Aurora Serverless), AppSync can connect via Data API to execute SQL commands via GraphQL mutation/query.\nAPI access can be managed in the following ways: AWS IAM, Cognito User Pools,… (authentication + authorization).\nBuilding Serverless APIs (Serverless with Lambda, API Gateway and SAM) Backend architecture uses Lambda, API Gateway, DynamoDB, S3, and Cognito.\nFrontend is a JavaScript application (Vue.js) hosted on S3 / Amplify.\nUse AWS SAM to define serverless resources and deploy backend (Lambda + API Gateway + DynamoDB)\nLambda reads / writes data from DynamoDB: for example, Lambda scans DynamoDB table to return list of “parks” (rides, attractions).\nDeploy API Gateway for frontend to call API; Lambda handles request logic.\nIn realtime: Lambda subscribes to SNS topic, saves information to DynamoDB, and forwards payload to IoT Core so frontend can receive real-time data.\nServerless Chat Application Build a serverless real-time chat application using API Gateway WebSocket, Lambda, and DynamoDB.\nWhen a client connects (“$connect”), Lambda stores the connection ID in DynamoDB.\nWhen a client disconnects (“$disconnect”), Lambda deletes the connection ID from DynamoDB.\nWhen a client sends a message (“sendmessage” route), Lambda reads the connection IDs from DynamoDB and uses the API Gateway Management API to broadcast the message to all connected clients.\n"
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/1-worklog/1.11-week11/",
	"title": "Week 11 Worklog",
	"tags": [],
	"description": "",
	"content": "Week 11 Objectives: Execute production deployment and go-live activities. Implement production monitoring and support procedures. Conduct user acceptance testing and bug fixes. Tasks to be carried out this week: Day Task Start Date Completion Date Reference Material 1 - Execute production deployment to AWS - Configure production environment variables - Run database migration and data seeding 17/11/2025 17/11/2025 Deployment Checklist, AWS Best Practices 2 - Conduct user acceptance testing with stakeholders - Document and prioritize identified issues - Create bug tracking and resolution workflow 18/11/2025 18/11/2025 UAT Test Plans, JIRA/Bug Tracking Tools 3 - Implement critical bug fixes and patches - Deploy hotfixes to production environment - Verify system stability and performance 19/11/2025 19/11/2025 Bug Fixing Procedures 4 - Set up production monitoring dashboards - Configure alerting for critical system metrics - Establish on-call support procedures 20/11/2025 20/11/2025 CloudWatch, PagerDuty Documentation 5 - Conduct post-deployment review - Document lessons learned - Create operational runbooks and troubleshooting guides 21/11/2025 21/11/2025 Operations Documentation Week 11 Achievements: Successfully deployed clothing e-commerce platform to production. Completed user acceptance testing with stakeholder approval. Resolved all critical and high-priority bugs identified during testing. Established comprehensive production monitoring and alerting system. Created detailed operational procedures and support documentation. Implemented automated backup and recovery procedures. Set up 24/7 monitoring with appropriate escalation procedures. Achieved production stability with minimal downtime during deployment. "
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/1-worklog/1.12-week12/",
	"title": "Week 12 Worklog",
	"tags": [],
	"description": "",
	"content": "Week 12 Objectives: Complete final project documentation and knowledge transfer. Conduct project retrospective and performance evaluation. Plan future enhancements and maintenance activities. Tasks to be carried out this week: Day Task Start Date Completion Date Reference Material 1 - Complete comprehensive project documentation - Create technical architecture documentation - Document API specifications and user guides 24/11/2025 24/11/2025 Technical Writing Best Practices 2 - Conduct knowledge transfer sessions with team - Create video tutorials for system operations - Document troubleshooting procedures 25/11/2025 25/11/2025 Knowledge Transfer Templates 3 - Perform final system performance analysis - Generate usage reports and metrics - Create recommendations for future improvements 26/11/2025 26/11/2025 Performance Analysis Tools 4 - Conduct project retrospective meeting - Document lessons learned and best practices - Create improvement recommendations 27/11/2025 27/11/2025 Retrospective Meeting Templates 5 - Finalize all project deliverables - Submit final project report - Prepare presentation for stakeholders 28/11/2025 28/11/2025 Project Management Documentation Week 12 Achievements: Completed comprehensive project documentation covering all aspects of the system. Successfully conducted knowledge transfer to ensure smooth handover. Generated detailed performance analysis and optimization recommendations. Documented all lessons learned and best practices for future reference. Delivered complete clothing e-commerce platform with AWS integration. Achieved all project objectives within timeline and budget constraints. Established maintenance procedures and future enhancement roadmap. Received positive feedback from stakeholders on project delivery and quality. "
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://nguyentanxuan.github.io/fcj/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]